<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atomic Puzzle Game - js13k Demo</title>
    <!-- Inline SVG favicon to avoid 404 -->
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3e%3ccircle cx='16' cy='16' r='12' fill='%23064e3b' stroke='%2369f' stroke-width='2'/%3e%3ccircle cx='16' cy='16' r='6' fill='%23fff' opacity='0.2'/%3e%3ccircle cx='22' cy='10' r='3' fill='%234a90e2'/%3e%3ccircle cx='10' cy='22' r='3' fill='%23ff6b35'/%3e%3c/svg%3e"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #020408; /* Very dark laboratory background */
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: "Courier New", monospace; /* Scientific/technical font */
      }

      canvas {
        border: 1px solid rgba(100, 150, 255, 0.2); /* Subtle blue glow */
        cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="12" fill="none" stroke="rgba(100,150,255,0.8)" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="none" stroke="rgba(100,150,255,0.6)" stroke-width="1"/><circle cx="16" cy="16" r="2" fill="rgba(100,150,255,0.9)"/><line x1="4" y1="16" x2="12" y2="16" stroke="rgba(100,150,255,0.7)" stroke-width="1"/><line x1="20" y1="16" x2="28" y2="16" stroke="rgba(100,150,255,0.7)" stroke-width="1"/><line x1="16" y1="4" x2="16" y2="12" stroke="rgba(100,150,255,0.7)" stroke-width="1"/><line x1="16" y1="20" x2="16" y2="28" stroke="rgba(100,150,255,0.7)" stroke-width="1"/></svg>')
            16 16,
          crosshair;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #96c8ff; /* Scientific blue */
        font-size: 12px;
        opacity: 0.8;
        font-family: "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">
      Atomic Puzzle Game - Guide electrons to matching colored orbitals
    </div>

    <!-- All Combined & Golfed JavaScript -->
  <script>

// Ultra-golfed electron for JS13K
class E {
  constructor(x, y, type, a) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.vx = 0;
    this.vy = 0;
    this.r = 8;
    this.captured = 0;
    this.inactive = 0;
    this.inactiveTime = 0;
    this.a = a;
    this.lastSound = 0;
    this.mouseInfluenced = 0;
  }

  update(mx, my, orbitals, orbitalSys) {
    if (this.captured) return;

    if (this.inactive > 0) {
      this.inactive -= 1 / 60;
      this.inactiveTime = this.inactive;
      if (this.inactive <= 0) {
        this.inactive = 0;
        this.inactiveTime = 0;
      }
      return;
    }

    // Mouse interaction
    let dx = mx - this.x,
      dy = my - this.y,
      dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 120) {
      this.mouseInfluenced = 1;
      let force = (0.3 * (120 - dist)) / 120;
      let fx = (dx / dist) * force,
        fy = (dy / dist) * force;

      if (this.type === 0) {
        // blue - attract to mouse
        this.vx += fx * 0.5;
        this.vy += fy * 0.5;
      } else {
        // orange - repel from mouse
        this.vx -= fx * 0.5;
        this.vy -= fy * 0.5;
      }
    } else this.mouseInfluenced = 0;

    // Orbital interactions
    for (let orb of orbitals) {
      if (orb.occupied || orb.stunned > 0.1) continue;

      let dx = orb.x - this.x,
        dy = orb.y - this.y,
        dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 60) {
        let force = (0.1 * (60 - dist)) / 60;
        let fx = (dx / dist) * force,
          fy = (dy / dist) * force;

        if (this.type === orb.type) {
          // attract to matching orbital
          this.vx += fx;
          this.vy += fy;
        } else {
          // repel from wrong orbital
          this.vx -= fx * 0.5;
          this.vy -= fy * 0.5;
        }
      }

      // Capture check
      if (orbitalSys.canEnter(orb, this.x, this.y)) {
        if (this.type === orb.type) {
          orb.occupied = 1;
          this.captured = 1;
          this.a?.p(1);
          return;
        } else {
          orbitalSys.stun(orb);
        }
      }

      // Hit occupied orbital
      if (orb.occupied && dist < 25) {
        orbitalSys.hit(orb);
        this.inactive = 3;
        this.inactiveTime = 3;
      }
    }

    // Apply physics
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 0.98;
    this.vy *= 0.98;

    // Boundaries with sound
    let speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
    let now = Date.now();

    if (this.x < this.r) {
      this.x = this.r;
      this.vx = -this.vx * 0.8;
      this.sound(speed, now);
    }
    if (this.x > 800 - this.r) {
      this.x = 800 - this.r;
      this.vx = -this.vx * 0.8;
      this.sound(speed, now);
    }
    if (this.y < this.r) {
      this.y = this.r;
      this.vy = -this.vy * 0.8;
      this.sound(speed, now);
    }
    if (this.y > 600 - this.r) {
      this.y = 600 - this.r;
      this.vy = -this.vy * 0.8;
      this.sound(speed, now);
    }

    // UI boundaries
    if (this.x < 220 && this.y < 120) {
      if (this.y > 110) {
        this.y = 120;
        this.vy = Math.abs(this.vy);
      }
      if (this.x > 210) {
        this.x = 220;
        this.vx = Math.abs(this.vx);
      }
    }
    if (this.y > 550) {
      this.y = 550;
      this.vy = -Math.abs(this.vy);
    }
  }

  sound(speed, now) {
    if (this.a?.p && now - this.lastSound > 200) {
      this.a.p(0, Math.min(1, speed / 6));
      this.lastSound = now;
    }
  }

  draw(ctx) {
    if (this.captured) return;

    ctx.save();

    // Colors: [blue,orange]
    let colors = [
      ["rgba(100,150,255,.8)", "rgb(150,200,255)", "rgb(100,150,255)"],
      ["rgba(255,150,100,.8)", "rgb(255,200,150)", "rgb(255,150,100)"],
    ];
    let c = colors[this.type] || [
      "rgba(128,128,128,.8)",
      "rgb(180,180,180)",
      "rgb(120,120,120)",
    ];

    if (this.mouseInfluenced && !this.inactive) {
      ctx.shadowColor = c[0];
      ctx.shadowBlur = 15;
    }

    let grad = ctx.createRadialGradient(
      this.x,
      this.y,
      0,
      this.x,
      this.y,
      this.r
    );

    if (this.inactive && this.inactiveTime > 0) {
      let pulse = 0.5 + 0.3 * Math.sin(Date.now() * 0.01);
      grad.addColorStop(0, `rgba(180,180,180,${pulse})`);
      grad.addColorStop(1, `rgba(120,120,120,${pulse * 0.7})`);
    } else {
      grad.addColorStop(0, c[1]);
      grad.addColorStop(1, c[2]);
    }

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, 6.28);
    ctx.fill();

    // Spin indicator
    if (!this.inactive) {
      ctx.fillStyle = c[1];
      ctx.font = "10px monospace";
      ctx.textAlign = "center";
      ctx.fillText(this.type ? "↑" : "↓", this.x, this.y + 3);
    }

    ctx.restore();
  }
}


// Ultra-golfed tutorial system for JS13K
class T {
  constructor(g) {
    this.g = g;
    this.v = 0;
    this.s = 0;
    this.o = null;
    this.h = localStorage.getItem("t") === "1";
    // Compact text data - indexed strings
    this.t = [
      "Welcome to Atomic Assembly!",
      "Learn Real Atomic Physics!",
      "Build atoms by placing electrons in correct orbitals",
      "Understanding Electron Spins",
      "Blue = Spin-Down, Orange = Spin-Up",
      "Each orbital holds max 2 electrons with opposite spins",
      "How to Play",
      "Mouse attracts/repels electrons - use physics!",
      "Match electron colors to orbital colors",
      "Time limit - complete before timeout",
      "Pro Tips",
      "Pauli Exclusion: max 2 electrons per orbital",
      "Hund's Rule: fill empty orbitals first",
      "Listen for audio feedback",
      "Continue",
      "Start Game",
    ];
    // Step data: [title_idx, content_start_idx, content_count, button_idx]
    this.d = [
      [0, 1, 2, 14],
      [3, 4, 1, 14],
      [6, 7, 2, 14],
      [10, 11, 3, 15],
    ];
  }

  show() {
    this.v = 1;
    this.s = 0;
    this.c();
    this.u();
  }

  hide() {
    this.v = 0;
    if (this.o) {
      this.o.remove();
      this.o = null;
    }
    localStorage.setItem("t", "1");
    this.h = 1;
  }

  c() {
    this.o = document.createElement("div");
    // Minimal inline styling
    this.o.style.cssText =
      "position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);display:flex;justify-content:center;align-items:center;z-index:1000;font:12px monospace;color:#ccc";

    this.o.innerHTML = `<div style="background:#111;border:2px solid #69f;width:90%;max-width:500px;max-height:80vh;overflow:auto">
      <div style="display:flex;justify-content:space-between;padding:15px;border-bottom:1px solid #69f;background:#222">
        <span>${this.s + 1}/4</span>
        <button onclick="tutorial.hide()" style="background:#333;border:1px solid #69f;color:#69f;padding:5px 10px">X</button>
      </div>
      <div style="padding:20px">
        <h2 style="color:#ff6;margin:0 0 15px;font-size:18px" class="title"></h2>
        <div class="content" style="line-height:1.5"></div>
      </div>
      <div style="display:flex;justify-content:flex-end;padding:15px;border-top:1px solid #69f;background:#222">
        <button onclick="tutorial.prev()" style="background:#333;border:1px solid #69f;color:#fa0;padding:8px 16px;margin-right:auto;display:none" class="prev">Previous</button>
        <button onclick="tutorial.next()" style="background:#333;border:1px solid #69f;color:#69f;padding:8px 16px" class="next">Next</button>
      </div>
    </div>`;

    document.body.appendChild(this.o);
  }

  u() {
    if (!this.o) return;
    let step = this.d[this.s];
    this.o.querySelector(".title").textContent = this.t[step[0]];
    let content = "";
    for (let i = 0; i < step[2]; i++) {
      content += this.t[step[1] + i] + "<br>";
    }
    this.o.querySelector(".content").innerHTML = content;
    this.o.querySelector(".prev").style.display = this.s > 0 ? "block" : "none";
    this.o.querySelector(".next").textContent = this.t[step[3]];
  }

  next() {
    if (this.s < 3) {
      this.s++;
      this.u();
    } else {
      this.hide();
      if (this.g && this.g.start) this.g.start();
    }
  }

  prev() {
    if (this.s > 0) {
      this.s--;
      this.u();
    }
  }

  shouldShow() {
    return !this.h;
  }
}


// Ultra-golfed orbital system for JS13K
class O {
  constructor(c, a) {
    this.c = c;
    this.l = 0;
    this.s = 0;
    this.t = 0;
    this.T = 45;
    this.a = a;
    this.w = 0;
    this.k = null;
    this.tip = 0;
    this.ts = 0;

    // Compact level data with proper shell positioning
    // [name,atomicNum,shells,orbitalData] - orbitalData: [x,y,radius,type,gap,speed,shellRadius]
    let CX = 400,
      CY = 300; // Center coordinates
    this.L = [
      ["Hydrogen", 1, [80], [[CX + 80, CY, 80, 0, 0.3, 0.02, 80]]],
      [
        "Helium",
        2,
        [80],
        [
          [CX + 80, CY, 80, 0, 0.3, 0.02, 80],
          [CX - 80, CY, 80, 0, 0.3, 0.02, 80],
        ],
      ],
      [
        "Lithium",
        3,
        [80, 140],
        [
          [CX + 80, CY, 80, 0, 0.3, 0.02, 80],
          [CX - 80, CY, 80, 0, 0.3, 0.02, 80],
          [CX + 140, CY, 140, 0, 0.25, 0.022, 140],
        ],
      ],
      [
        "Carbon",
        6,
        [80, 140],
        [
          [CX + 80, CY, 80, 0, 0.3, 0.02, 80],
          [CX - 80, CY, 80, 0, 0.3, 0.02, 80],
          [CX + 140, CY, 140, 0, 0.25, 0.022, 140],
          [CX - 140, CY, 140, 0, 0.25, 0.022, 140],
          [CX, CY + 140, 140, 1, 0.25, 0.022, 140],
          [CX, CY - 140, 140, 1, 0.25, 0.022, 140],
        ],
      ],
      [
        "Nitrogen",
        7,
        [80, 140],
        [
          [CX + 80, CY, 80, 0, 0.3, 0.02, 80],
          [CX - 80, CY, 80, 0, 0.3, 0.02, 80],
          [CX + 140, CY, 140, 0, 0.25, 0.022, 140],
          [CX - 140, CY, 140, 0, 0.25, 0.022, 140],
          [CX, CY + 140, 140, 1, 0.25, 0.022, 140],
          [CX, CY - 140, 140, 1, 0.25, 0.022, 140],
          [CX + 99, CY + 99, 140, 1, 0.25, 0.022, 140],
        ],
      ],
    ];

    // Facts compressed - with line breaks for better display
    this.F = [
      "Simplest atom - just 1 proton\nand 1 electron",
      "Noble gas - completely filled\nelectron shell",
      "Alkali metal - very reactive\ndue to single outer electron",
      "Forms 4 bonds - basis of\nall organic chemistry",
      "Essential for proteins\nand DNA",
    ];

    this.r();
  }

  setMouse(x, y) {
    this.m = { x, y };
  }

  r() {
    let lvl = this.L[this.l];
    this.o = [];
    for (let i = 0; i < lvl[3].length; i++) {
      let d = lvl[3][i];
      this.o.push({
        x: d[0],
        y: d[1],
        r: d[2],
        type: d[3],
        gap: d[4],
        speed: d[5],
        shellR: d[6] || d[2], // Shell radius for drawing
        angle: Math.random() * 6.28,
        occupied: 0,
        stunned: 0,
        eAngle: 0,
        baseSpeed: d[5], // Store original speed for capture cone
        inCone: 0, // For capture assistance
      });
    }
    this.t = 0;
    this.w = 0;
  }

  update() {
    this.t += 1 / 60;
    for (let orb of this.o) {
      // Speed management for orange orbs
      if (orb.type === 1 && !orb.occupied) {
        // Impulse tap mechanic - slow down when mouse is near
        let mouseX = this.m?.x || 0;
        let mouseY = this.m?.y || 0;
        let dx = mouseX - orb.x;
        let dy = mouseY - orb.y;
        let dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 80) {
          // Create capture cone effect
          orb.inCone = Math.max(0.5, orb.inCone);
          orb.speed = orb.baseSpeed * 0.3; // 70% slower
        } else {
          orb.inCone = Math.max(0, orb.inCone - 0.02);
          orb.speed = orb.baseSpeed * (0.3 + 0.7 * (1 - orb.inCone));
        }
      }

      orb.angle += orb.speed;
      if (orb.occupied) orb.eAngle += 0.05;
      if (orb.stunned > 0) orb.stunned -= 1 / 60;
    }
    if (this.tip && this.t - this.ts > 4) this.tip = 0;
  }

  checkComplete() {
    return this.o.filter((o) => o.occupied).length === this.o.length;
  }

  canEnter(orb, x, y) {
    if (orb.occupied || orb.stunned > 0.1) return 0;
    let dx = x - orb.x,
      dy = y - orb.y,
      dist = Math.sqrt(dx * dx + dy * dy);

    // Collision should be with the 20px orbital ring, not the shell
    let orbitalRadius = 20;
    let maxDist = orb.type === 1 ? 25 : 22; // Orange orbs get slightly larger zone
    let minDist = orb.type === 1 ? 15 : 18;

    if (dist > maxDist || dist < minDist) return 0;

    let angle = Math.atan2(dy, dx);
    let diff = Math.abs(angle - orb.angle);
    if (diff > Math.PI) diff = 6.28 - diff;

    // Wider gap for orange orbs and capture assistance
    let gapSize = orb.gap;
    if (orb.type === 1) gapSize *= 1.4; // 40% wider for orange
    if (orb.inCone > 0) gapSize *= 1.2; // 20% wider when in capture cone

    return diff < gapSize / 2;
  }

  stun(orb) {
    orb.stunned = 2;
    this.a?.p(4);
  }

  hit(orb) {
    orb.hits = (orb.hits || 0) + 1;
    if (orb.hits >= 2) {
      orb.occupied = 0;
      orb.hits = 0;
      this.k = { type: orb.type, time: this.t };
      this.a?.p(2);
    } else this.a?.p(3);
  }

  nextLevel() {
    if (this.checkComplete()) {
      this.s += (this.l + 1) * 100;
      this.tip = 1;
      this.ts = this.t;
      this.l++;
      if (this.l >= this.L.length) this.l = 0;
      this.r();
      return 1;
    }
    return 0;
  }

  draw(ctx) {
    // Colors: [blue,orange]
    let colors = [
      ["rgba(100,150,255,", "rgb(100,150,255)"],
      ["rgba(255,150,100,", "rgb(255,150,100)"],
    ];
    let lvl = this.L[this.l];
    let CX = this.c.width / 2,
      CY = this.c.height / 2;

    // Shell outlines
    let shells = new Set();
    for (let orb of this.o) {
      shells.add(orb.shellR);
    }
    ctx.save();
    ctx.strokeStyle = "rgba(100,150,200,.3)";
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    for (let r of shells) {
      ctx.beginPath();
      ctx.arc(CX, CY, r, 0, 6.28);
      ctx.stroke();
    }
    ctx.setLineDash([]);
    ctx.restore();

    // Nucleus
    ctx.save();
    ctx.shadowColor = "rgba(255,255,100,.8)";
    ctx.shadowBlur = 15;
    let grad = ctx.createRadialGradient(CX, CY, 0, CX, CY, 15);
    grad.addColorStop(0, "rgb(255,255,150)");
    grad.addColorStop(1, "rgb(200,150,50)");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(CX, CY, 12, 0, 6.28);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgb(50,50,50)";
    ctx.font = "10px monospace";
    ctx.textAlign = "center";
    ctx.fillText(lvl[0].charAt(0), CX, CY + 3);
    ctx.restore();

    // Orbitals
    for (let orb of this.o) {
      ctx.save();
      let c = colors[orb.type];
      let stunned = orb.stunned > 0.1;

      // Capture cone for orange orbs
      if (orb.type === 1 && orb.inCone > 0.1 && !orb.occupied) {
        ctx.save();
        ctx.strokeStyle = `rgba(255,150,100,${orb.inCone * 0.4})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(orb.x, orb.y, 80, 0, 6.28);
        ctx.stroke();
        ctx.restore();
      }

      // Orbital ring with enhanced capture zone for orange
      let ringOpacity = orb.type === 1 && orb.inCone > 0.1 ? 0.9 : 0.7;
      ctx.strokeStyle = stunned
        ? "rgba(120,120,120,.6)"
        : c[0] + `${ringOpacity})`;
      ctx.lineWidth = orb.type === 1 && orb.inCone > 0.1 ? 3 : 2;
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, 20, 0, 6.28);
      ctx.stroke();

      if (orb.occupied) {
        // Electron orbiting
        let ex = orb.x + Math.cos(orb.eAngle) * 18;
        let ey = orb.y + Math.sin(orb.eAngle) * 18;
        let eGrad = ctx.createRadialGradient(ex, ey, 0, ex, ey, 8);
        eGrad.addColorStop(0, c[1]);
        eGrad.addColorStop(1, c[1].replace("rgb", "rgba").replace(")", ",0)"));
        ctx.fillStyle = eGrad;
        ctx.beginPath();
        ctx.arc(ex, ey, 8, 0, 6.28);
        ctx.fill();
      } else {
        // Entry gap
        ctx.translate(orb.x, orb.y);
        ctx.rotate(orb.angle);
        ctx.strokeStyle = stunned
          ? "rgba(200,200,200,.8)"
          : c[1].replace("rgb", "rgba").replace(")", ".9)");
        ctx.lineWidth = 3;
        ctx.beginPath();
        let g = orb.gap / 2;
        ctx.arc(0, 0, 20, g, 6.28 - g);
        ctx.stroke();

        // Gap indicators
        ctx.strokeStyle = stunned
          ? "rgba(160,160,160,.9)"
          : c[1].replace("rgb", "rgba").replace(")", ".8)");
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(20 * Math.cos(g), 20 * Math.sin(g));
        ctx.lineTo(14 * Math.cos(g), 14 * Math.sin(g));
        ctx.moveTo(20 * Math.cos(-g), 20 * Math.sin(-g));
        ctx.lineTo(14 * Math.cos(-g), 14 * Math.sin(-g));
        ctx.stroke();

        // Center dot
        let pulse = 0.3 + 0.3 * Math.sin(this.t * 2.5);
        ctx.fillStyle = stunned
          ? `rgba(140,140,140,${pulse})`
          : c[0] + `${pulse})`;
        ctx.beginPath();
        ctx.arc(0, 0, 3, 0, 6.28);
        ctx.fill();
      }
      ctx.restore();
    }

    // UI
    ctx.fillStyle = "white";
    ctx.font = "18px monospace";
    ctx.fillText(lvl[0], 20, 30);

    // Atomic number box
    ctx.fillStyle = "rgba(100,150,255,.2)";
    ctx.fillRect(200, 10, 40, 30);
    ctx.strokeStyle = "rgb(100,150,255)";
    ctx.strokeRect(200, 10, 40, 30);
    ctx.fillStyle = "rgb(0,255,255)";
    ctx.font = "14px monospace";
    ctx.textAlign = "center";
    ctx.fillText(lvl[1], 220, 30);
    ctx.textAlign = "left";

    ctx.fillStyle = "white";
    ctx.font = "18px monospace";
    ctx.fillText(`SCORE: ${this.s}`, 20, 55);
    ctx.fillText(
      `Electrons: ${this.o.filter((o) => o.occupied).length}/${this.o.length}`,
      20,
      75
    );

    let timeLeft = Math.max(0, this.T - this.t);
    ctx.fillStyle = timeLeft < 10 ? "rgb(255,100,100)" : "white";
    ctx.fillText(`Time: ${timeLeft.toFixed(1)}s`, 20, 95);

    if (timeLeft <= 10 && timeLeft > 0 && !this.w && this.a) {
      this.a.p(6);
      this.w = 1;
    }

    // Completion check
    if (this.checkComplete()) {
      ctx.save();
      // Modal background
      ctx.fillStyle = "rgba(0,0,0,.8)";
      ctx.fillRect(0, 0, this.c.width, this.c.height);

      // Modal box
      let boxW = 400,
        boxH = 120;
      let boxX = (this.c.width - boxW) / 2,
        boxY = (this.c.height - boxH) / 2;

      ctx.fillStyle = "rgba(20,30,50,.95)";
      ctx.fillRect(boxX, boxY, boxW, boxH);
      ctx.strokeStyle = "rgb(255,255,100)";
      ctx.lineWidth = 3;
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      // Content
      ctx.textAlign = "center";
      ctx.font = "24px monospace";
      ctx.shadowColor = "rgb(255,255,0)";
      ctx.shadowBlur = 15;
      ctx.fillStyle = "rgb(255,255,100)";
      ctx.fillText("LEVEL COMPLETE!", this.c.width / 2, boxY + 45);

      ctx.font = "16px monospace";
      ctx.shadowColor = "rgb(0,255,255)";
      ctx.shadowBlur = 8;
      ctx.fillStyle = "rgb(100,200,255)";
      ctx.fillText(">> CLICK FOR NEXT LEVEL <<", this.c.width / 2, boxY + 75);
      ctx.restore();
    } else if (timeLeft <= 0) {
      ctx.save();
      // Modal background
      ctx.fillStyle = "rgba(0,0,0,.8)";
      ctx.fillRect(0, 0, this.c.width, this.c.height);

      // Modal box
      let boxW = 400,
        boxH = 100;
      let boxX = (this.c.width - boxW) / 2,
        boxY = (this.c.height - boxH) / 2;

      ctx.fillStyle = "rgba(50,20,20,.95)";
      ctx.fillRect(boxX, boxY, boxW, boxH);
      ctx.strokeStyle = "rgb(255,100,100)";
      ctx.lineWidth = 3;
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      // Content
      ctx.textAlign = "center";
      ctx.font = "20px monospace";
      ctx.shadowColor = "rgb(255,100,100)";
      ctx.shadowBlur = 15;
      ctx.fillStyle = "rgb(255,150,150)";
      ctx.fillText("TIME'S UP! CLICK TO RETRY", this.c.width / 2, boxY + 60);
      ctx.restore();
    }

    // Educational tip
    if (this.tip) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.8)";
      ctx.fillRect(0, 0, this.c.width, this.c.height);

      let boxW = 400,
        boxH = 170; // Increased height for multi-line text
      let boxX = (this.c.width - boxW) / 2,
        boxY = (this.c.height - boxH) / 2;

      ctx.fillStyle = "rgba(20,30,50,.95)";
      ctx.fillRect(boxX, boxY, boxW, boxH);
      ctx.strokeStyle = "rgb(100,150,255)";
      ctx.lineWidth = 2;
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      ctx.textAlign = "center";
      ctx.fillStyle = "rgb(255,255,100)";
      ctx.font = "20px monospace";
      ctx.fillText("ELEMENT BUILT!", this.c.width / 2, boxY + 35);

      let prevIdx = this.l === 0 ? this.L.length - 1 : this.l - 1;
      ctx.fillStyle = "rgb(100,200,255)";
      ctx.font = "16px monospace";
      ctx.fillText(this.L[prevIdx][0], this.c.width / 2, boxY + 60);

      // Handle multi-line text
      ctx.fillStyle = "rgb(255,200,100)";
      ctx.font = "14px monospace";
      const lines = this.F[prevIdx].split('\n');
      lines.forEach((line, i) => {
        ctx.fillText(line, this.c.width / 2, boxY + 85 + i * 18);
      });

      ctx.fillStyle = "rgba(150,150,150,.8)";
      ctx.font = "12px monospace";
      ctx.fillText(
        `(Auto-closes in ${Math.ceil(4 - (this.t - this.ts))}s)`,
        this.c.width / 2,
        boxY + 140
      );

      ctx.restore();
    }
  }
}


// Ultra-golfed audio system for JS13K
class A {
  constructor() {
    this.c = null;
    this.g = null;
    this.muted = 0;
    this.s = [];
  }

  async i() {
    if (this.c) return;
    this.c = new (AudioContext || webkitAudioContext)();
    this.g = this.c.createGain();
    this.g.gain.value = 0.3;
    this.g.connect(this.c.destination);

    // Create echo bus for spatial effect
    this.delay = this.c.createDelay(0.5);
    this.delay.delayTime.value = 0.15;
    this.feedback = this.c.createGain();
    this.feedback.gain.value = 0.25;
    this.delay.connect(this.feedback);
    this.feedback.connect(this.delay);
    this.delay.connect(this.g);

    // Create all SFX buffers - fast attacks, bell-like releases
    this.s = [
      this.b([1, 800, 0.3, 0.3, 0.002, 0.2]), // 0: collision
      this.b([1, 659, 0.35, 0.4, 0.005, 0.25]), // 1: capture
      this.b([2, 311, 0.25, 0.3, 0.002, 0.15]), // 2: knocked out
      this.b([3, 207, 0.3, 0.35, 0.002, 0.2]), // 3: wrong electron
      this.b([1, 247, 0.2, 0.25, 0.002, 0.12]), // 4: orbital stun
      this.b([1, 1175, 0.12, 0.15, 0.001, 0.08]), // 5: UI hover
      this.b([1, 698, 0.35, 0.4, 0.003, 0.25]), // 6: time warning
      this.b([1, 523, 0.5, 0.5, 0.01, 0.3]), // 7: level complete
      this.b([1, 1318, 0.4, 0.3, 0.002, 0.3]), // 8: twinkle for captures
    ];
  }

  // Create buffer from params [wave,freq,dur,vol,attack,release]
  b(p) {
    const l = this.c.sampleRate * p[2];
    const buf = this.c.createBuffer(1, l, this.c.sampleRate);
    const d = buf.getChannelData(0);
    const a = p[4] * this.c.sampleRate;
    const r = (p[2] - p[5]) * this.c.sampleRate;

    for (let i = 0; i < l; i++) {
      let v;
      if (p[0] == 1)
        v = Math.sin((i * p[1] * 6.28) / this.c.sampleRate); // sine
      else if (p[0] == 2) v = Math.random() * 2 - 1; // noise
      else v = (((i * p[1] * 4) / this.c.sampleRate) % 2) - 1; // sawtooth

      let e = 1;
      if (i < a) e = i / a;
      else if (i > r) e = (l - i) / (l - r);

      d[i] = v * e * p[3];
    }
    return buf;
  }

  // Play SFX by index with optional echo
  p(i, v = 1, echo = false) {
    if (!this.c || this.muted) return;
    const s = this.c.createBufferSource();
    const g = this.c.createGain();
    s.buffer = this.s[i];
    g.gain.value = v;
    s.connect(g);
    g.connect(this.g);
    if (echo && this.delay) g.connect(this.delay);
    s.start();

    // Add twinkle for successful captures
    if (i === 1) {
      setTimeout(() => this.p(8, 0.6, true), 100);
    }
  }

  // Start ambient music - gentle musical progression
  m() {
    if (!this.c) return;

    // Chord progression: Am - F - C - G (vi-IV-I-V in C major)
    const chords = [
      [220, 264, 330], // Am (A-C-E)
      [175, 220, 262], // F (F-A-C)
      [196, 247, 294], // C (C-E-G)
      [196, 247, 294], // G (G-B-D) - simplified to fit
    ];

    const melodyNotes = [
      440,
      392,
      349,
      330,
      294,
      330,
      349,
      392, // Gentle descending phrase
      440,
      523,
      494,
      440,
      392,
      349,
      330,
      294, // Rise and fall
    ];

    let chordIndex = 0;
    let melodyIndex = 0;

    // Bass foundation (subtle)
    const bass = this.c.createOscillator();
    const bassGain = this.c.createGain();
    bass.type = "sine";
    bass.frequency.value = 110; // Low A
    bassGain.gain.setValueAtTime(0, this.c.currentTime);
    bassGain.gain.linearRampToValueAtTime(0.006, this.c.currentTime + 4);
    bass.connect(bassGain);
    bassGain.connect(this.g);
    bass.start();

    // Chord pad (3 voices)
    const chordOscs = [];
    for (let i = 0; i < 3; i++) {
      const osc = this.c.createOscillator();
      const gain = this.c.createGain();
      const filter = this.c.createBiquadFilter();

      osc.type = "triangle";
      filter.type = "lowpass";
      filter.frequency.value = 600;
      filter.Q.value = 0.7;

      gain.gain.setValueAtTime(0, this.c.currentTime);
      gain.gain.linearRampToValueAtTime(0.008, this.c.currentTime + 3 + i);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(this.g);
      osc.start();

      chordOscs.push({ osc, gain });
    }

    // Melody voice
    const melody = this.c.createOscillator();
    const melodyGain = this.c.createGain();
    const melodyFilter = this.c.createBiquadFilter();

    melody.type = "sine";
    melodyFilter.type = "lowpass";
    melodyFilter.frequency.value = 1200;
    melodyGain.gain.setValueAtTime(0, this.c.currentTime);

    melody.connect(melodyFilter);
    melodyFilter.connect(melodyGain);
    melodyGain.connect(this.g);
    if (this.delay) melodyGain.connect(this.delay);
    melody.start();

    // Chord progression (every 8 seconds)
    const changeChord = () => {
      const currentChord = chords[chordIndex];

      // Update bass note
      if (bass.frequency) {
        const bassNote = currentChord[0] / 2; // Octave down
        bass.frequency.exponentialRampToValueAtTime(
          bassNote,
          this.c.currentTime + 1
        );
      }

      // Update chord voices
      chordOscs.forEach((voice, i) => {
        if (voice.osc.frequency) {
          voice.osc.frequency.exponentialRampToValueAtTime(
            currentChord[i],
            this.c.currentTime + 1.5
          );
        }
      });

      chordIndex = (chordIndex + 1) % chords.length;
      setTimeout(changeChord, 8000);
    };

    // Melody notes (every 2-3 seconds)
    const playMelodyNote = () => {
      const note = melodyNotes[melodyIndex];

      if (melody.frequency) {
        // Gentle note entry
        melodyGain.gain.cancelScheduledValues(this.c.currentTime);
        melodyGain.gain.setValueAtTime(0, this.c.currentTime);
        melodyGain.gain.linearRampToValueAtTime(
          0.004,
          this.c.currentTime + 0.3
        );
        melodyGain.gain.linearRampToValueAtTime(0.001, this.c.currentTime + 2);

        melody.frequency.exponentialRampToValueAtTime(
          note,
          this.c.currentTime + 0.1
        );
      }

      melodyIndex = (melodyIndex + 1) % melodyNotes.length;
      setTimeout(playMelodyNote, 2500 + Math.random() * 1000);
    };

    // Start sequences
    setTimeout(changeChord, 4000); // First chord change after 4s
    setTimeout(playMelodyNote, 6000); // First melody note after 6s
  }

  // Mute toggle
  t() {
    this.muted = !this.muted;
    this.g.gain.value = this.muted ? 0 : 0.3;
    return this.muted;
  }
}

// Usage shortcuts
// a.p(0) - collision
// a.p(1) - capture (with auto-twinkle)
// a.p(2) - knocked out
// a.p(3) - wrong electron
// a.p(4) - orbital stun
// a.p(5) - UI hover
// a.p(6) - time warning
// a.p(7) - level complete
// a.p(8) - twinkle (auto-triggered)


// Ultra-golfed game for JS13K
class G {
  constructor() {
    this.c = document.getElementById("gameCanvas");
    this.ctx = this.c.getContext("2d");

    // Systems
    this.input = { mouse: { x: 400, y: 300 } };
    this.c.addEventListener("mousemove", (e) => {
      let rect = this.c.getBoundingClientRect();
      this.input.mouse.x = e.clientX - rect.left;
      this.input.mouse.y = e.clientY - rect.top;
      this.orbitals.setMouse(this.input.mouse.x, this.input.mouse.y);
    });

    this.audio = new A();
    this.orbitals = new O(this.c, this.audio);
    this.tutorial = new T(this);

    this.electrons = [];
    this.particles = [];

    this.spawn();
    this.spawnParticles();

    // Click handler
    this.c.addEventListener("click", async () => {
      if (!this.audio.c) {
        await this.audio.i();
        this.audio.m();
      }

      if (this.orbitals.tip) {
        this.orbitals.tip = 0;
        this.audio.p(5);
        return;
      }

      let timeLeft = Math.max(0, this.orbitals.T - this.orbitals.t);
      if (this.orbitals.checkComplete()) {
        this.audio.p(7); // level complete (need to add this sound)
        this.orbitals.nextLevel();
        this.spawn();
      } else if (timeLeft <= 0) {
        this.audio.p(6); // game over
        this.orbitals.r();
        this.spawn();
      }
    });

    // Keyboard
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (this.orbitals.tip) {
          this.orbitals.tip = 0;
        } else {
          this.tutorial.show();
        }
      } else if (e.key === "m" || e.key === "M") {
        this.audio.t();
      } else if (e.key === "r" || e.key === "R") {
        this.orbitals.l = 0;
        this.orbitals.s = 0;
        this.orbitals.r();
        this.spawn();
        this.audio.p(5);
      }
    });

    this.loop();

    // Show tutorial
    setTimeout(() => {
      if (this.tutorial.shouldShow()) this.tutorial.show();
    }, 1000);
  }

  spawn() {
    this.electrons = [];
    let types = [0, 1]; // blue,orange
    types.forEach((type) => {
      let count = this.orbitals.o.filter((o) => o.type === type).length;
      for (let i = 0; i < count; i++) {
        let x,
          y,
          attempts = 0;
        do {
          x = Math.random() * (this.c.width - 200) + 100;
          y = Math.random() * (this.c.height - 200) + 100;
          attempts++;
        } while (attempts < 10 && this.nearOrbital(x, y, 60));

        this.electrons.push(new E(x, y, type, this.audio));
      }
    });
  }

  respawn(type) {
    let x,
      y,
      attempts = 0;
    do {
      x = Math.random() * (this.c.width - 200) + 100;
      y = Math.random() * (this.c.height - 200) + 100;
      attempts++;
    } while (attempts < 10 && this.nearOrbital(x, y, 60));

    let e = new E(x, y, type, this.audio);
    e.vx = (Math.random() - 0.5) * 3;
    e.vy = (Math.random() - 0.5) * 3;
    this.electrons.push(e);
  }

  nearOrbital(x, y, minDist) {
    return this.orbitals.o.some((o) => {
      let dx = x - o.x,
        dy = y - o.y;
      return Math.sqrt(dx * dx + dy * dy) < minDist;
    });
  }

  spawnParticles() {
    this.particles = [];
    for (let i = 0; i < 20; i++) {
      this.particles.push({
        x: Math.random() * this.c.width,
        y: Math.random() * this.c.height,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        alpha: Math.random() * 0.4 + 0.1,
        phase: Math.random() * 6.28,
        size: Math.random() * 1.5 + 0.5,
      });
    }
  }

  update() {
    this.orbitals.update();

    // Check for knocked out electron respawn
    if (this.orbitals.k) {
      this.respawn(this.orbitals.k.type);
      this.orbitals.k = null;
    }

    // Update particles
    for (let p of this.particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.phase += 0.02;

      if (p.x < 0) p.x = this.c.width;
      if (p.x > this.c.width) p.x = 0;
      if (p.y < 0) p.y = this.c.height;
      if (p.y > this.c.height) p.y = 0;
    }

    // Update electrons
    for (let e of this.electrons) {
      e.update(
        this.input.mouse.x,
        this.input.mouse.y,
        this.orbitals.o,
        this.orbitals
      );
    }
  }

  draw() {
    this.ctx.fillStyle = "rgb(10,10,20)";
    this.ctx.fillRect(0, 0, this.c.width, this.c.height);

    // Background particles
    this.ctx.save();
    for (let p of this.particles) {
      let twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(p.phase));
      this.ctx.fillStyle = `rgba(200,220,255,${p.alpha * twinkle})`;
      this.ctx.beginPath();
      this.ctx.arc(p.x, p.y, p.size, 0, 6.28);
      this.ctx.fill();
    }
    this.ctx.restore();

    // Cursor glow
    if (!this.orbitals.tip) {
      this.ctx.save();
      this.ctx.shadowColor = "rgba(100,150,255,.6)";
      this.ctx.shadowBlur = 20;
      this.ctx.fillStyle = "rgba(100,150,255,.2)";
      this.ctx.beginPath();
      this.ctx.arc(this.input.mouse.x, this.input.mouse.y, 15, 0, 6.28);
      this.ctx.fill();
      this.ctx.restore();
    }

    this.orbitals.draw(this.ctx);

    // Draw electrons
    if (!this.orbitals.tip) {
      for (let e of this.electrons) {
        e.draw(this.ctx);
      }
    }

    // Instructions
    this.ctx.fillStyle = "rgba(255,255,255,.7)";
    this.ctx.font = "12px monospace";
    this.ctx.fillText(
      "Blue↓ attract, Orange↑ repel | M:Mute R:Restart ESC:Help",
      20,
      this.c.height - 20
    );
  }

  loop() {
    this.update();
    this.draw();
    requestAnimationFrame(() => this.loop());
  }

  start() {
    console.log("Game started");
  }
}



// Initialize the golfed game
window.game = new G();
window.tutorial = window.game.tutorial; // Make tutorial globally accessible
  </script>
    <script>
      // Start the game
      window.game = new G();
      window.tutorial = window.game.tutorial; // Make tutorial globally accessible
    </script>
  </body>
</html>
