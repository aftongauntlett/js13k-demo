<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atomic Puzzle Game - js13k Demo</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #020408; /* Very dark laboratory background */
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: "Courier New", monospace; /* Scientific/technical font */
      }

      canvas {
        border: 1px solid rgba(100, 150, 255, 0.2); /* Subtle blue glow */
        cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="12" fill="none" stroke="rgba(100,150,255,0.8)" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="none" stroke="rgba(100,150,255,0.6)" stroke-width="1"/><circle cx="16" cy="16" r="2" fill="rgba(100,150,255,0.9)"/><line x1="4" y1="16" x2="12" y2="16" stroke="rgba(100,150,255,0.7)" stroke-width="1"/><line x1="20" y1="16" x2="28" y2="16" stroke="rgba(100,150,255,0.7)" stroke-width="1"/><line x1="16" y1="4" x2="16" y2="12" stroke="rgba(100,150,255,0.7)" stroke-width="1"/><line x1="16" y1="20" x2="16" y2="28" stroke="rgba(100,150,255,0.7)" stroke-width="1"/></svg>')
            16 16,
          crosshair;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #96c8ff; /* Scientific blue */
        font-size: 12px;
        opacity: 0.8;
        font-family: "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">
      Atomic Puzzle Game - Guide electrons to matching colored orbitals
    </div>

    <script>
// Simple electron with polarity-based physics
class Electron {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = (Math.random() - 0.5) * 2;
    this.type = type; // 'blue', 'orange', or 'grey'
    this.originalType = type; // Store original type for recovery
    this.radius = 8;
    this.captured = false;
    this.mouseInfluenced = false;
    this.inactive = false; // True when electron becomes grey/inactive
    this.inactiveTime = 0; // Time remaining inactive
    this.TAU = Math.PI * 2; // 2Ï€ constant for efficiency
  }

  // Handle boundary collisions for all scenarios
  handleBoundaries(canvasWidth, canvasHeight) {
    // UI collision boundaries - invisible walls around text areas
    // Top-left UI area (level, score, timer)
    if (this.x < 220 && this.y < 120) {
      if (this.x < 220 && this.y > 110) {
        // Bottom edge of UI area
        this.y = 120;
        this.vy = Math.abs(this.vy);
      } else if (this.x > 210 && this.y < 120) {
        // Right edge of UI area
        this.x = 220;
        this.vx = Math.abs(this.vx);
      }
    }

    // Bottom instruction text area
    if (this.y > canvasHeight - 50) {
      this.y = canvasHeight - 50;
      this.vy = -Math.abs(this.vy);
    }

    // Canvas boundaries
    if (this.x < this.radius) {
      this.x = this.radius;
      this.vx = Math.abs(this.vx);
    }
    if (this.x > canvasWidth - this.radius) {
      this.x = canvasWidth - this.radius;
      this.vx = -Math.abs(this.vx);
    }
    if (this.y < this.radius) {
      this.y = this.radius;
      this.vy = Math.abs(this.vy);
    }
    if (this.y > canvasHeight - this.radius) {
      this.y = canvasHeight - this.radius;
      this.vy = -Math.abs(this.vy);
    }
  }

  update(mouseX, mouseY, orbitals, orbitalSystem) {
    if (this.captured) return;

    const M = Math; // Shorter reference for size optimization

    // Handle inactive electron recovery
    if (this.inactive) {
      this.inactiveTime -= 1 / 60; // Decrease by 1/60th second (assuming 60fps)
      if (this.inactiveTime <= 0) {
        // Reactivate electron
        this.inactive = false;
        this.type = this.originalType;
      } else {
        // Still inactive, just update physics but no mouse interaction
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.x += this.vx;
        this.y += this.vy;

        // Use shared boundary handling
        this.handleBoundaries(
          orbitalSystem.canvas.width,
          orbitalSystem.canvas.height
        );
        return;
      }
    }

    let dx = this.x - mouseX,
      dy = this.y - mouseY;
    let distance = M.sqrt(dx * dx + dy * dy);

    // Track if mouse is close enough to influence electron (only if not inactive)
    this.mouseInfluenced = distance < 150;

    if (distance > 0 && this.mouseInfluenced) {
      let force = this.type === "blue" ? -0.15 : 0.15;
      this.vx += (dx / distance) * force;
      this.vy += (dy / distance) * force;
    }

    this.vx *= 0.98;
    this.vy *= 0.98;
    this.x += this.vx;
    this.y += this.vy;

    // Get canvas bounds from orbital system
    let canvasWidth = orbitalSystem.canvas.width;
    let canvasHeight = orbitalSystem.canvas.height;

    // Handle all boundary collisions
    this.handleBoundaries(canvasWidth, canvasHeight);

    // Orbital interactions
    for (let orbital of orbitals) {
      let odx = this.x - orbital.x,
        ody = this.y - orbital.y;
      let odist = M.sqrt(odx * odx + ody * ody);

      if (odist < orbital.radius + this.radius) {
        if (orbital.occupied && !this.inactive) {
          // Hit an occupied orbital - trigger shake/knockout
          let electronKnockedOut = orbitalSystem.hitOccupiedOrbital(orbital);

          if (electronKnockedOut) {
            // Create a new electron to replace the knocked-out one
            // Spawn it near the orbital but with some random velocity
            let newElectron = new Electron(
              orbital.x + (M.random() - 0.5) * 100,
              orbital.y + (M.random() - 0.5) * 100,
              orbital.type
            );
            // Add some initial velocity to the new electron
            newElectron.vx = (M.random() - 0.5) * 4;
            newElectron.vy = (M.random() - 0.5) * 4;

            // Add the new electron to the game
            // We need access to the electrons array from the game instance
            // For now, we'll store it in a way the game can pick it up
            if (window.game) {
              window.game.electrons.push(newElectron);
            }
          }

          // Bounce away from orbital
          let bounceX = odx / odist,
            bounceY = ody / odist;
          this.vx = bounceX * 3;
          this.vy = bounceY * 3;
          this.x = orbital.x + bounceX * (orbital.radius + this.radius + 2);
          this.y = orbital.y + bounceY * (orbital.radius + this.radius + 2);
        } else if (orbital.type === this.type) {
          // Correct color orbital
          if (!orbital.occupied) {
            // Check if electron can enter this orbital (considers rotation gaps)
            if (
              this.mouseInfluenced &&
              orbitalSystem.canEnterOrbital(orbital, this.x, this.y)
            ) {
              // Electron can enter - capture it
              orbital.occupied = true;
              this.captured = true;
              this.x = orbital.x;
              this.y = orbital.y;
              break;
            } else if (orbital.rotate) {
              // Rotating orbital but electron can't enter through gap - bounce
              let bounceX = odx / odist,
                bounceY = ody / odist;
              this.vx = bounceX * 3;
              this.vy = bounceY * 3;
              this.x = orbital.x + bounceX * (orbital.radius + this.radius + 2);
              this.y = orbital.y + bounceY * (orbital.radius + this.radius + 2);
            }
          }
        } else if (!orbital.occupied && !this.inactive) {
          // Wrong color orbital - make electron inactive and stun orbital
          this.inactive = true;
          this.type = "grey";
          this.mouseInfluenced = false;
          this.inactiveTime = 5; // Inactive for 5 seconds
          orbitalSystem.stunOrbital(orbital);

          // Bounce away from orbital
          let bounceX = odx / odist,
            bounceY = ody / odist;
          this.vx = bounceX * 3;
          this.vy = bounceY * 3;
          this.x = orbital.x + bounceX * (orbital.radius + this.radius + 2);
          this.y = orbital.y + bounceY * (orbital.radius + this.radius + 2);
        }
      }
    }
  }

  draw(ctx) {
    if (this.captured) return;

    const M = Math; // Shorter reference for size optimization
    ctx.save();

    // Color map for electrons
    const colors = {
      blue: ["rgba(100,150,255,0.8)", "rgb(150,200,255)", "rgb(100,150,255)"],
      orange: ["rgba(255,150,100,0.8)", "rgb(255,200,150)", "rgb(255,150,100)"],
    };

    // Add subtle glow when mouse-influenced (but not if inactive)
    if (this.mouseInfluenced && !this.inactive) {
      ctx.shadowColor = colors[this.type]
        ? colors[this.type][0]
        : "rgba(128,128,128,0.8)";
      ctx.shadowBlur = 15;
    }

    let grad = ctx.createRadialGradient(
      this.x,
      this.y,
      0,
      this.x,
      this.y,
      this.radius
    );

    if (colors[this.type]) {
      let c = colors[this.type];
      grad.addColorStop(0, c[1]);
      grad.addColorStop(1, c[2]);
    } else {
      // Grey/inactive electron with recovery indicator
      if (this.inactive && this.inactiveTime > 0) {
        // Add pulsing effect as it recovers
        let pulse = 0.5 + 0.3 * M.sin(Date.now() * 0.01);
        grad.addColorStop(0, `rgba(180,180,180,${pulse})`);
        grad.addColorStop(1, `rgba(120,120,120,${pulse * 0.7})`);
      } else {
        grad.addColorStop(0, "rgb(180,180,180)");
        grad.addColorStop(1, "rgb(120,120,120)");
      }
    }

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, this.TAU);
    ctx.fill();
    ctx.restore();
  }
}


// Simple input handling for mouse position
class InputSystem {
  constructor(canvas) {
    this.mouse = { x: canvas.width / 2, y: canvas.height / 2 };

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      this.mouse.x = e.clientX - rect.left;
      this.mouse.y = e.clientY - rect.top;
    });
  }
}


// Simple atomic orbital system with progressive levels
class OrbitalSystem {
  constructor(canvas) {
    this.canvas = canvas;
    this.currentLevel = 0;
    this.score = 0;
    this.TAU = Math.PI * 2; // 2Ï€ constant for efficiency
    this.time = 0;
    this.levelTime = 45; // 45 seconds per level

    // Orbital factory for consistent properties and smaller code
    const G3 = Math.PI / 3,
      G4 = Math.PI / 4,
      G5 = Math.PI / 5,
      G6 = Math.PI / 6;

    // Center coordinates for atomic structure
    const CX = this.canvas.width / 2;
    const CY = this.canvas.height / 2;

    // Shell factory: (shell, position_angle, type, gap_size, rotation_speed)
    const shell = (radius, angle, type, gap = G4, speed = 0.02) => ({
      x: CX + Math.cos(angle) * radius,
      y: CY + Math.sin(angle) * radius,
      type,
      speed,
      gap,
      radius: 20,
      rotate: true,
      shell: radius, // Track which shell this belongs to
    });

    // Real atomic structures based on Bohr model
    this.levels = [
      {
        name: "Hydrogen (H)",
        element: "H",
        atomicNumber: 1,
        description: "1 electron in 1s orbital",
        orbitals: [
          shell(60, 0, "blue", G3, 0.025), // 1sÂ¹
        ],
      },
      {
        name: "Helium (He)",
        element: "He",
        atomicNumber: 2,
        description: "2 electrons fill the first shell",
        orbitals: [
          shell(60, 0, "blue", G4, 0.022), // 1sÂ¹
          shell(60, Math.PI, "blue", G4, 0.022), // 1sÂ²
        ],
      },
      {
        name: "Lithium (Li)",
        element: "Li",
        atomicNumber: 3,
        description: "2 electrons in 1s, 1 electron in 2s",
        orbitals: [
          // First shell (1sÂ² - complete)
          shell(50, 0, "blue", G6, 0.018),
          shell(50, Math.PI, "blue", G6, 0.018),
          // Second shell (2sÂ¹)
          shell(100, Math.PI / 2, "orange", G3, 0.025),
        ],
      },
      {
        name: "Carbon (C)",
        element: "C",
        atomicNumber: 6,
        description: "1sÂ² 2sÂ² 2pÂ²",
        orbitals: [
          // First shell (1sÂ² - complete, smaller, faster)
          shell(45, 0, "blue", G6, 0.015),
          shell(45, Math.PI, "blue", G6, 0.015),
          // Second shell (2sÂ² 2pÂ²)
          shell(90, 0, "orange", G4, 0.02), // 2sÂ¹
          shell(90, Math.PI, "orange", G4, 0.02), // 2sÂ²
          shell(90, Math.PI / 2, "orange", G4, 0.022), // 2pÂ¹
          shell(90, (3 * Math.PI) / 2, "orange", G4, 0.022), // 2pÂ²
        ],
      },
      {
        name: "Nitrogen (N)",
        element: "N",
        atomicNumber: 7,
        description: "1sÂ² 2sÂ² 2pÂ³",
        orbitals: [
          // First shell (1sÂ²)
          shell(40, 0, "blue", G6, 0.012),
          shell(40, Math.PI, "blue", G6, 0.012),
          // Second shell (2sÂ² 2pÂ³)
          shell(85, 0, "orange", G4, 0.018),
          shell(85, Math.PI, "orange", G4, 0.018),
          shell(85, Math.PI / 2, "orange", G5, 0.02),
          shell(85, (3 * Math.PI) / 2, "orange", G5, 0.02),
          shell(85, Math.PI / 4, "orange", G5, 0.022),
        ],
      },
    ];

    this.resetLevel();
  }

  resetLevel() {
    this.orbitals = this.levels[this.currentLevel].orbitals.map((o) => ({
      x: o.x,
      y: o.y,
      radius: o.radius,
      type: o.type,
      occupied: false,
      rotate: o.rotate,
      speed: o.speed,
      gap: o.gap,
      angle: 0,
      stunned: false,
      stunnedTime: 0,
      hitCount: 0,
      shaking: false,
      shakeTime: 0,
      shakeOffsetX: 0,
      shakeOffsetY: 0,
    }));
    this.time = 0;
  }

  checkCompletion() {
    return this.orbitals.every((o) => o.occupied);
  }

  update() {
    const M = Math; // Shorter reference
    this.time += 1 / 60; // Assuming 60fps

    // Update rotating orbitals
    for (let orbital of this.orbitals) {
      if (orbital.rotate) {
        orbital.angle += orbital.speed;
      }

      // Update stunned orbitals
      if (orbital.stunned) {
        orbital.stunnedTime -= 1 / 60;
        if (orbital.stunnedTime <= 0) {
          orbital.stunned = false;
        }
      }

      // Update shaking orbitals
      if (orbital.shaking) {
        orbital.shakeTime -= 1 / 60;
        if (orbital.shakeTime <= 0) {
          orbital.shaking = false;
          orbital.shakeOffsetX = 0;
          orbital.shakeOffsetY = 0;
        } else {
          // Generate random shake offset
          let intensity = orbital.shakeTime * 8; // Fade out over time
          orbital.shakeOffsetX = (M.random() - 0.5) * intensity;
          orbital.shakeOffsetY = (M.random() - 0.5) * intensity;
        }
      }
    }
  }

  // Check if electron can enter orbital gap
  canEnterOrbital(orbital, electronX, electronY) {
    if (orbital.stunned) return false; // Stunned orbitals can't accept electrons

    let dx = electronX - orbital.x,
      dy = electronY - orbital.y;
    let electronAngle = Math.atan2(dy, dx);
    let relativeAngle = (electronAngle - orbital.angle + this.TAU) % this.TAU;

    return (
      relativeAngle < orbital.gap || relativeAngle > this.TAU - orbital.gap
    );
  }

  // Stun an orbital when wrong-color electron hits it
  stunOrbital(orbital) {
    orbital.stunned = true;
    orbital.stunnedTime = 3; // 3 seconds stun duration
  }

  // Handle hits on occupied orbitals
  hitOccupiedOrbital(orbital) {
    orbital.hitCount++;
    orbital.shaking = true;
    orbital.shakeTime = 0.5; // Shake for 0.5 seconds

    if (orbital.hitCount >= 2) {
      // Knock out the electron
      orbital.occupied = false;
      orbital.hitCount = 0;
      orbital.shaking = false;
      orbital.shakeOffsetX = 0;
      orbital.shakeOffsetY = 0;
      return true; // Electron was knocked out
    }
    return false; // Electron still in orbital
  }

  nextLevel() {
    if (this.checkCompletion()) {
      this.score += (this.currentLevel + 1) * 100;
      this.currentLevel++;
      if (this.currentLevel >= this.levels.length) {
        this.currentLevel = 0; // Loop back
      }
      this.resetLevel();
      return true;
    }
    return false;
  }

  draw(ctx) {
    // Color helpers for smaller code
    const colors = {
      blue: ["rgba(100,150,255,", "rgb(100,150,255)", "rgb(80,120,200)"],
      orange: ["rgba(255,150,100,", "rgb(255,150,100)", "rgb(200,120,80)"],
      grey: "rgb(128,128,128)",
    };

    const level = this.levels[this.currentLevel];
    const CX = this.canvas.width / 2;
    const CY = this.canvas.height / 2;

    // Draw nucleus at center
    ctx.save();
    ctx.shadowColor = "rgba(255, 255, 100, 0.8)";
    ctx.shadowBlur = 15;

    let nucleusGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, 15);
    nucleusGrad.addColorStop(0, "rgb(255, 255, 150)");
    nucleusGrad.addColorStop(0.7, "rgb(255, 200, 100)");
    nucleusGrad.addColorStop(1, "rgb(200, 150, 50)");

    ctx.fillStyle = nucleusGrad;
    ctx.beginPath();
    ctx.arc(CX, CY, 12, 0, this.TAU);
    ctx.fill();

    // Nucleus label
    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgb(50, 50, 50)";
    ctx.font = "10px 'Courier New', monospace";
    ctx.textAlign = "center";
    ctx.fillText(level.element, CX, CY + 3);
    ctx.textAlign = "left";
    ctx.restore();

    // Draw electron shells as concentric circles around nucleus
    // Group orbitals by shell distance from center
    const shells = {};
    for (let orbital of this.orbitals) {
      const shellRadius = orbital.shell;
      if (!shells[shellRadius]) shells[shellRadius] = [];
      shells[shellRadius].push(orbital);
    }

    // Draw each shell as a complete circle with electron positions
    for (let shellRadius in shells) {
      const shellOrbitals = shells[shellRadius];
      const radius = parseInt(shellRadius);
      
      ctx.save();
      
      // Draw the shell orbital path (faint circle)
      ctx.strokeStyle = "rgba(100, 150, 255, 0.2)";
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(CX, CY, radius, 0, this.TAU);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw electrons on this shell
      for (let orbital of shellOrbitals) {
        ctx.save();
        
        let c = colors[orbital.type] || colors.grey;
        let occ = orbital.occupied;
        let stunned = orbital.stunned;

        if (occ) {
          // Occupied position - show electron
          ctx.shadowColor = c[0] + "0.8)";
          ctx.shadowBlur = 15;

          // Apply shake offset for occupied orbitals
          let drawX = orbital.x + orbital.shakeOffsetX;
          let drawY = orbital.y + orbital.shakeOffsetY;

          let grad = ctx.createRadialGradient(
            drawX, drawY, 0, drawX, drawY, 8
          );
          grad.addColorStop(0, c[1]);
          grad.addColorStop(1, c[2]);

          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(drawX, drawY, 8, 0, this.TAU);
          ctx.fill();
        } else {
          // Available electron position with rotating gap
          const angle = orbital.angle || 0;
          const gapSize = orbital.gap;
          
          // Draw the available orbital spot as an arc with gap
          ctx.translate(CX, CY);
          ctx.rotate(angle);
          
          // Calculate the position on the shell for this orbital
          const orbitalAngle = Math.atan2(orbital.y - CY, orbital.x - CX);
          ctx.rotate(orbitalAngle);
          
          ctx.strokeStyle = stunned ? colors.grey : c[2];
          ctx.lineWidth = 4;
          ctx.beginPath();
          
          // Draw arc representing the available electron position
          ctx.arc(0, 0, radius, -gapSize/2, gapSize/2);
          ctx.stroke();
          
          // Draw gap indicators
          ctx.strokeStyle = stunned ? "rgba(128,128,128,0.6)" : c[0] + "0.6)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          let r1 = radius - 5, r2 = radius + 5;
          ctx.moveTo(r1 * Math.cos(gapSize/2), r1 * Math.sin(gapSize/2));
          ctx.lineTo(r2 * Math.cos(gapSize/2), r2 * Math.sin(gapSize/2));
          ctx.moveTo(r1 * Math.cos(-gapSize/2), r1 * Math.sin(-gapSize/2));
          ctx.lineTo(r2 * Math.cos(-gapSize/2), r2 * Math.sin(-gapSize/2));
          ctx.stroke();
        }
        
        ctx.restore();
      }
      
      ctx.restore();
    }

    // UI Constants
    const F16 = "16px Arial",
      F18 = "18px 'Courier New', monospace",
      F12 = "12px Arial";
    const WHITE = "white",
      CYAN = "rgb(0, 255, 255)",
      YELLOW = "rgb(255, 255, 100)";

    const currentLevel = this.levels[this.currentLevel];

    // Element name and atomic number
    ctx.fillStyle = WHITE;
    ctx.font = F18;
    ctx.fillText(`${currentLevel.name}`, 20, 30);

    // Atomic number in a styled box
    ctx.save();
    ctx.fillStyle = "rgba(100, 150, 255, 0.2)";
    ctx.fillRect(200, 10, 40, 30);
    ctx.strokeStyle = "rgb(100, 150, 255)";
    ctx.lineWidth = 1;
    ctx.strokeRect(200, 10, 40, 30);

    ctx.fillStyle = CYAN;
    ctx.font = "14px 'Courier New', monospace";
    ctx.textAlign = "center";
    ctx.fillText(currentLevel.atomicNumber.toString(), 220, 30);
    ctx.textAlign = "left";
    ctx.restore();

    // Enhanced score text with glow effect
    ctx.save();
    ctx.font = F18;
    ctx.textAlign = "left";

    // Glow effect for score
    ctx.shadowColor = CYAN;
    ctx.shadowBlur = 8;
    ctx.fillStyle = CYAN;
    ctx.fillText(`SCORE: ${this.score}`, 20, 55);

    ctx.restore();

    // Electron configuration description
    ctx.fillStyle = YELLOW;
    ctx.font = F12;
    ctx.fillText(currentLevel.description, 20, 75);

    ctx.fillStyle = WHITE;
    ctx.font = F16;
    ctx.fillText(
      `Electrons: ${this.orbitals.filter((o) => o.occupied).length}/${
        this.orbitals.length
      }`,
      20,
      95
    );

    // Timer display
    let timeLeft = Math.max(0, this.levelTime - this.time);
    ctx.fillStyle = timeLeft < 10 ? "rgb(255,100,100)" : "white";
    ctx.fillText(`Time: ${timeLeft.toFixed(1)}s`, 20, 115);

    if (this.checkCompletion()) {
      ctx.save();

      // Center the completion text
      ctx.textAlign = "center";
      ctx.font = "32px 'Courier New', monospace";

      // Multiple glow layers for enhanced effect
      ctx.shadowColor = "rgb(255, 255, 0)";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "rgb(255, 255, 0)";
      ctx.fillText("LEVEL COMPLETE", this.canvas.width / 2, 150);

      // Secondary glow
      ctx.shadowColor = "rgb(255, 200, 0)";
      ctx.shadowBlur = 30;
      ctx.fillStyle = "rgb(255, 255, 200)";
      ctx.fillText("LEVEL COMPLETE", this.canvas.width / 2, 150);

      // Smaller instruction text
      ctx.font = "18px 'Courier New', monospace";
      ctx.shadowColor = "rgb(0, 255, 255)";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "rgb(0, 255, 255)";
      ctx.fillText(">> CLICK FOR NEXT LEVEL <<", this.canvas.width / 2, 180);

      ctx.restore();
    } else if (timeLeft <= 0) {
      ctx.save();
      ctx.textAlign = "center";
      ctx.font = "24px 'Courier New', monospace";
      ctx.shadowColor = "rgb(255, 100, 100)";
      ctx.shadowBlur = 15;
      ctx.fillStyle = "rgb(255, 100, 100)";
      ctx.fillText("TIME'S UP! CLICK TO RETRY", this.canvas.width / 2, 150);
      ctx.restore();
    }
  }
}


// Simple atomic physics game
class Game {
  constructor() {
    this.canvas = document.getElementById("gameCanvas");
    this.ctx = this.canvas.getContext("2d");

    // Systems
    this.input = new InputSystem(this.canvas);
    this.orbitals = new OrbitalSystem(this.canvas);

    // Electrons
    this.electrons = [];
    this.spawnElectrons();

    // Background particles for atmosphere
    this.particles = [];
    this.spawnParticles();

    // Click handler for level progression/restart
    this.canvas.addEventListener("click", () => {
      let timeLeft = Math.max(0, this.orbitals.levelTime - this.orbitals.time);
      if (this.orbitals.checkCompletion()) {
        this.orbitals.nextLevel();
        this.spawnElectrons();
      } else if (timeLeft <= 0) {
        this.orbitals.resetLevel();
        this.spawnElectrons();
      }
    });

    this.gameLoop();
  }

  spawnElectrons() {
    this.electrons = [];

    // Count and spawn electrons for each type
    ["blue", "orange"].forEach((type) => {
      let count = this.orbitals.orbitals.filter((o) => o.type === type).length;
      for (let i = 0; i < count; i++) {
        this.electrons.push(
          new Electron(
            Math.random() * (this.canvas.width - 100) + 50,
            Math.random() * (this.canvas.height - 100) + 50,
            type
          )
        );
      }
    });
  }

  spawnParticles() {
    this.particles = [];
    // Create subtle background particles
    for (let i = 0; i < 30; i++) {
      this.particles.push({
        x: Math.random() * this.canvas.width,
        y: Math.random() * this.canvas.height,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        alpha: Math.random() * 0.4 + 0.1,
        phase: Math.random() * Math.PI * 2,
        size: Math.random() * 1.5 + 0.5,
      });
    }
  }

  update() {
    this.orbitals.update();

    // Update particles with subtle drift and twinkling
    for (let p of this.particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.phase += 0.02;

      // Wrap around edges
      if (p.x < 0) p.x = this.canvas.width;
      if (p.x > this.canvas.width) p.x = 0;
      if (p.y < 0) p.y = this.canvas.height;
      if (p.y > this.canvas.height) p.y = 0;
    }

    for (let electron of this.electrons) {
      electron.update(
        this.input.mouse.x,
        this.input.mouse.y,
        this.orbitals.orbitals,
        this.orbitals
      );
    }
  }

  draw() {
    this.ctx.fillStyle = "rgb(10,10,20)";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // Draw background particles
    this.ctx.save();
    for (let p of this.particles) {
      let twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(p.phase));
      this.ctx.fillStyle = `rgba(200,220,255,${p.alpha * twinkle})`;
      this.ctx.beginPath();
      this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      this.ctx.fill();
    }
    this.ctx.restore();

    // Draw cursor glow
    this.ctx.save();
    this.ctx.shadowColor = "rgba(100,150,255,0.6)";
    this.ctx.shadowBlur = 20;
    this.ctx.fillStyle = "rgba(100,150,255,0.2)";
    this.ctx.beginPath();
    this.ctx.arc(this.input.mouse.x, this.input.mouse.y, 15, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.restore();

    this.orbitals.draw(this.ctx);

    for (let electron of this.electrons) {
      electron.draw(this.ctx);
    }

    this.ctx.fillStyle = "rgba(255,255,255,0.7)";
    this.ctx.font = "12px Arial";
    this.ctx.fillText(
      "Orange repel, blue attract | Guide electrons through rotating gaps with mouse",
      20,
      this.canvas.height - 20
    );
  }

  gameLoop() {
    this.update();
    this.draw();
    requestAnimationFrame(() => this.gameLoop());
  }
}


// Start the game
const game = new Game();
</script>
  </body>
</html>
