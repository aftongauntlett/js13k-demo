<!DOCTYPE html>
<html lan      canvas {
        border: 1px solid rgba(100, 150, 255, 0.2); /* Subtle blue glow */
        cursor: none;
      }>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atomic Puzzle Game - js13k Demo</title>
    <!-- Inline SVG favicon to avoid 404 -->
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3e%3ccircle cx='16' cy='16' r='12' fill='%23064e3b' stroke='%2369f' stroke-width='2'/%3e%3ccircle cx='16' cy='16' r='6' fill='%23fff' opacity='0.2'/%3e%3ccircle cx='22' cy='10' r='3' fill='%234a90e2'/%3e%3ccircle cx='10' cy='22' r='3' fill='%23ff6b35'/%3e%3c/svg%3e"
    />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #020408;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: "Courier New", monospace;
      }

      canvas {
        border: 1px solid rgba(100, 150, 255, 0.2);
        cursor: none;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #96c8ff;
        font-size: 16px;
        opacity: 0.9;
        font-family: "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">
      Orbital Order (Aufbau) - Guide electrons to matching colored orbitals
    </div>

    <!-- All Combined & Golfed JavaScript -->
  <script>

class E {
  constructor(x, y, type, a) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.vx = 0;
    this.vy = 0;
    this.r = 8;
    this.captured = 0;
    this.inactive = 0;
    this.inactiveTime = 0;
    this.a = a;
    this.lastSound = 0;
    this.mouseInfluenced = 0;
  }

  u(mouse, orbitals, game) {
    if (this.captured) return;
    if (!orbitals || !Array.isArray(orbitals)) return;

    if (this.inactive > 0) {
      this.inactive -= 1 / 60;
      this.inactiveTime = this.inactive;
      if (this.inactive <= 0) {
        this.inactive = 0;
        this.inactiveTime = 0;
      }
      return;
    }

    let dx = mouse.x - this.x,
      dy = mouse.y - this.y,
      dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 120) {
      this.mouseInfluenced = 1;
      let force = (0.3 * (120 - dist)) / 120;
      let fx = (dx / dist) * force,
        fy = (dy / dist) * force;

      if (this.type === 0) {
        this.vx += fx * 0.5;
        this.vy += fy * 0.5;
      } else {
        this.vx -= fx * 0.5;
        this.vy -= fy * 0.5;
      }
    } else this.mouseInfluenced = 0;

    for (let orb of orbitals) {
      let dx = orb.x - this.x,
        dy = orb.y - this.y,
        dist = Math.sqrt(dx * dx + dy * dy);

      if (orb.stunned <= 0.1 && dist < 60) {
        let force = (0.1 * (60 - dist)) / 60;
        let fx = (dx / dist) * force,
          fy = (dy / dist) * force;

        if (this.type === orb.type) {
          this.vx += fx;
          this.vy += fy;
        } else {
          this.vx -= fx * 0.5;
          this.vy -= fy * 0.5;
        }
      }

      if (dist < 25) {
        if (!orb.occupied && orb.stunned <= 0.1 && this.type === orb.type) {
          if (game.canEnter(orb, this.x, this.y)) {
            orb.occupied = 1;
            this.captured = 1;
            orb.stunCount = 0;
            if (this.a?.c) {
              this.a.p(1, 0.5);
            }
            return;
          } else {
            let repelForce = 8;
            let repelX = ((this.x - orb.x) / dist) * repelForce;
            let repelY = ((this.y - orb.y) / dist) * repelForce;
            this.vx = repelX;
            this.vy = repelY;

            let pushOut = 30;
            this.x = orb.x + ((this.x - orb.x) / dist) * pushOut;
            this.y = orb.y + ((this.y - orb.y) / dist) * pushOut;

            this.inactive = 0.3;
            this.inactiveTime = 0.3;
            if (this.a?.c) {
              this.a.p(3, 0.3);
            }
            game.stun(orb, false);
            return;
          }
        } else if (!orb.occupied && this.type !== orb.type) {
          let repelForce = 12;
          let repelX = ((this.x - orb.x) / dist) * repelForce;
          let repelY = ((this.y - orb.y) / dist) * repelForce;
          this.vx = repelX;
          this.vy = repelY;

          let pushOut = 30;
          this.x = orb.x + ((this.x - orb.x) / dist) * pushOut;
          this.y = orb.y + ((this.y - orb.y) / dist) * pushOut;

          this.inactive = 0.3;
          this.inactiveTime = 0.3;
          if (this.a?.c) {
            this.a.p(3, 0.3);
          }
          game.stun(orb, false);
          return;
        } else if (orb.occupied) {
          let repelForce = 12;
          let repelX = ((this.x - orb.x) / dist) * repelForce;
          let repelY = ((this.y - orb.y) / dist) * repelForce;
          this.vx = repelX;
          this.vy = repelY;

          let pushOut = 30;
          this.x = orb.x + ((this.x - orb.x) / dist) * pushOut;
          this.y = orb.y + ((this.y - orb.y) / dist) * pushOut;

          this.inactive = 0.3;
          this.inactiveTime = 0.3;
          game.hit(orb);
          return;
        }
      }
    }
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 0.98;
    this.vy *= 0.98;
    let speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
    let now = Date.now();
    let r = this.r;
    if (this.x < r) {
      this.x = r;
      this.vx = -this.vx * 0.8;
      this.sound(speed, now);
    }
    if (this.x > 800 - r) {
      this.x = 800 - r;
      this.vx = -this.vx * 0.8;
      this.sound(speed, now);
    }
    if (this.y < r) {
      this.y = r;
      this.vy = -this.vy * 0.8;
      this.sound(speed, now);
    }
    if (this.y > 600 - r) {
      this.y = 600 - r;
      this.vy = -this.vy * 0.8;
      this.sound(speed, now);
    }

    if (this.x < 220 && this.y < 120) {
      if (this.y > 110) {
        this.y = 120;
        this.vy = Math.abs(this.vy);
      }
      if (this.x > 210) {
        this.x = 220;
        this.vx = Math.abs(this.vx);
      }
    }
    if (this.y > 550) {
      this.y = 550;
      this.vy = -Math.abs(this.vy);
    }
    if (this.x > 580 && this.y < 100) {
      if (this.y > 90) {
        this.y = 100;
        this.vy = Math.abs(this.vy);
      }
      if (this.x < 590) {
        this.x = 580;
        this.vx = -Math.abs(this.vx);
      }
    }
  }

  sound(speed, now) {
    if (this.a?.c && this.a?.p && now - this.lastSound > 30) {
      this.a.p(0, Math.min(0.6, speed / 6));
      this.lastSound = now;
    }
  }

  d(ctx) {
    if (this.captured) return;

    ctx.save();

    let colors = [
      ["rgba(100,150,255,.8)", "rgb(150,200,255)", "rgb(100,150,255)"],
      ["rgba(255,150,100,.8)", "rgb(255,200,150)", "rgb(255,150,100)"],
    ];
    let c = colors[this.type] || [
      "rgba(128,128,128,.8)",
      "rgb(180,180,180)",
      "rgb(120,120,120)",
    ];

    if (this.mouseInfluenced && !this.inactive) {
      ctx.shadowColor = c[0];
      ctx.shadowBlur = 15;
    }

    let grad = ctx.createRadialGradient(
      this.x,
      this.y,
      0,
      this.x,
      this.y,
      this.r
    );

    if (this.inactive && this.inactiveTime > 0) {
      let pulse = 0.5 + 0.3 * Math.sin(Date.now() * 0.01);
      grad.addColorStop(0, `rgba(180,180,180,${pulse})`);
      grad.addColorStop(1, `rgba(120,120,120,${pulse * 0.7})`);
    } else {
      grad.addColorStop(0, c[1]);
      grad.addColorStop(1, c[2]);
    }

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r, 0, 6.28);
    ctx.fill();

    if (!this.inactive) {
      ctx.fillStyle = c[1];
      ctx.font = "10px monospace";
      ctx.textAlign = "center";
      ctx.fillText(this.type ? "p" : "s", this.x, this.y + 3);
    }

    ctx.restore();
  }
}


class T {
  constructor(g) {
    this.g = g;
    this.v = 0;
    this.o = null;
    this.h = localStorage.getItem("t") === "1";
  }

  show() {
    if (this.v) return;
    this.v = 1;
    this.c();
  }

  hide() {
    this.v = 0;
    if (this.o) {
      this.o.remove();
      this.o = null;
    }
    localStorage.setItem("t", "1");
    this.h = 1;
  }

  c() {
    if (this.o) this.o.remove();
    this.o = document.createElement("div");
    this.o.style.cssText =
      "position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.9);display:flex;justify-content:center;align-items:center;z-index:1000;font:12px monospace;color:#ccc";

    this.o.innerHTML = `<div style="background:#111;border:2px solid #69f;width:90%;max-width:600px;max-height:80vh;display:flex;flex-direction:column">
      <div style="padding:15px;border-bottom:1px solid #69f;background:#222;display:flex;justify-content:space-between;align-items:center;flex-shrink:0">
        <h2 style="margin:0;color:#ff6">Atomic Assembly Guide</h2>
        <button style="background:#333;border:1px solid #69f;color:#69f;padding:5px 10px;cursor:pointer">✕</button>
      </div>
      <div style="padding:20px;line-height:1.4;overflow:auto;flex:1">
        <h3 style="color:#fa0;margin:0 0 10px">How to Play</h3>
        <p>• Guide electrons into orbitals with your cursor<br>
        • Blue electrons (s) are ATTRACTED to your mouse<br>
        • Orange electrons (p) are REPELLED by your mouse<br>
        • Max 2 electrons per orbital</p>
        
        <h3 style="color:#fa0;margin:20px 0 10px">Rules</h3>
        <p>• Fill inner shells before outer shells<br>
        • s-orbitals must be filled before p-orbitals<br>
        • Avoid hitting occupied orbitals (causes ejection penalty)<br>
        • Complete all 6 elements to unlock infinite mode<br>
        • Earn an an achievement for completing all levels the fastest<br>
        • Infinite mode features electromagnetic storms that affect electrons</p>
        
        <h3 style="color:#fa0;margin:20px 0 10px">Controls</h3>
        <p>• Mouse: attract blue electrons, repel orange ones<br>
        • M: mute/unmute audio<br>
        • ESC: this help menu</p>
        
        <h3 style="color:#fa0;margin:20px 0 10px">Elements</h3>
        <p>• <b>Hydrogen (H)</b> - Simplest atom, 1 proton, 1 electron<br>
        • <b>Helium (He)</b> - Noble gas with filled electron shell<br>
        • <b>Lithium (Li)</b> - Alkali metal, reactive outer electron<br>
        • <b>Carbon (C)</b> - Forms 4 bonds, basis of organic chemistry<br>
        • <b>Nitrogen (N)</b> - Essential for proteins and DNA<br>
        • <b>Oxygen (O)</b> - Reactive gas, forms water, supports combustion</p>
        
        <h3 style="color:#fa0;margin:20px 0 10px">Scientific Principles</h3>
        <p>• <b>Aufbau Principle</b> - Fill lower energy orbitals first<br>
        • <b>Pauli Exclusion</b> - Max 2 electrons per orbital<br>
        • <b>Hund's Rule</b> - Fill orbitals singly before pairing<br>
        • <b>Electron Shells</b> - Energy levels around the nucleus<br>
        • <b>s-orbitals vs p-orbitals</b> - Different shapes and energy levels<br>
        • <b>Electromagnetic Storms</b> - Chaotic fields that disrupt electron movement</p>
      </div>
    </div>`;
    this.o.querySelector("button").onclick = () => this.hide();

    document.body.appendChild(this.o);
  }

  shouldShow() {
    return !this.h && !this.v;
  }

  isVisible() {
    return this.v;
  }
}


class O {
  constructor(ctx, audio, gameRef) {
    this.BLUE = "rgba(100,150,255,";
    this.ORANGE = "rgba(255,150,100,";
    this.DARK_BG = "rgba(20,30,50,.95)";
    this.OVERLAY = "rgba(0,0,0,.9)";

    this.PI2 = 6.28;
    this.RND = () => Math.random();

    this.e = [];
    this.ctx = ctx;
    this.audio = audio;
    this.gameRef = gameRef;

    this.L = [
      ["Hydrogen", 1, 1.008, "H", [80], [[480, 300, 0, 80]]],
      [
        "Helium",
        2,
        4.003,
        "He",
        [80],
        [
          [480, 300, 0, 80],
          [320, 300, 0, 80],
        ],
      ],
      [
        "Lithium",
        3,
        6.941,
        "Li",
        [80, 140],
        [
          [480, 300, 0, 80],
          [320, 300, 0, 80],
          [540, 300, 0, 140],
        ],
      ],
      [
        "Carbon",
        6,
        12.011,
        "C",
        [80, 140],
        [
          [480, 300, 0, 80],
          [320, 300, 0, 80],
          [540, 300, 0, 140],
          [260, 300, 0, 140],
          [400, 440, 1, 140],
          [400, 160, 1, 140],
        ],
      ],
      [
        "Nitrogen",
        7,
        14.007,
        "N",
        [80, 140],
        [
          [480, 300, 0, 80],
          [320, 300, 0, 80],
          [540, 300, 0, 140],
          [260, 300, 0, 140],
          [400, 440, 1, 140],
          [400, 160, 1, 140],
          [499, 399, 1, 140],
        ],
      ],
      [
        "Oxygen",
        8,
        15.999,
        "O",
        [80, 140],
        [
          [480, 300, 0, 80],
          [320, 300, 0, 80],
          [540, 300, 0, 140],
          [260, 300, 0, 140],
          [400, 440, 1, 140],
          [400, 160, 1, 140],
          [499, 399, 1, 140],
          [301, 399, 1, 140],
        ],
      ],
    ];

    this.F = [
      "Simplest atom\nMakes up 75% of universe",
      "Noble gas - never reacts\nUsed in balloons & diving",
      "Lightest metal\nUsed in phone batteries",
      "Forms 4 bonds\nBase of all life on Earth",
      "Essential for DNA\nMakes up 78% of air",
      "Supports combustion\n21% of Earth's atmosphere",
    ];

    this.l = 0;
    this.cycle = 0;
    this.storms = [];
    this.startTime = Date.now();

    this.bestTimeNotification = 0;
    this.newBestTime = 0;

    this.r();
  }

  drawModal(ctx, x, y, w, h, borderColor = this.ORANGE + "1)", lineWidth = 3) {
    ctx.fillStyle = this.OVERLAY;
    ctx.fillRect(0, 0, 800, 600);

    ctx.fillStyle = this.DARK_BG;
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = lineWidth;
    ctx.strokeRect(x, y, w, h);
    ctx.textAlign = "center";
  }

  drawStyledText(ctx, text, x, y, font, color, shadowColor, shadowBlur) {
    ctx.font = font;
    ctx.fillStyle = color;
    if (shadowColor) {
      ctx.shadowColor = shadowColor;
      ctx.shadowBlur = shadowBlur;
    }
    ctx.fillText(text, x, y);
    if (shadowColor) ctx.shadowBlur = 0;
  }

  r() {
    let lvl = this.L[this.l];
    this.o = [];
    for (let i = 0; i < lvl[5].length; i++) {
      let d = lvl[5][i];
      this.o.push({
        x: d[0],
        y: d[1],
        type: d[2],
        shellR: d[3],
        occupied: 0,
        stunned: 0,
        eAngle: 0,
        hits: 0,
        shake: 0,
      });
    }

    if (this.cycle === 0) {
      this.storms = [];
      this.startTime = Date.now();
    }
  }

  u() {
    let menuOpen = (this.g && this.g.tutorial && this.g.tutorial.v) || this.tip;

    if (this.checkComplete() && !this.tip && !this.completionDelay) {
      if (this.cycle > 0) {
        this.nextLevel();
        return;
      } else {
        this.completionDelay = 1.0;
        this.shellGlow = 1;
      }
    }

    if (this.completionDelay > 0) {
      this.completionDelay -= 1 / 60;
      this.shellGlow = Math.max(0, this.shellGlow - 1 / 120);
      if (this.completionDelay <= 0) {
        this.tip = 1;
        this.shellGlow = 0;
      }
    }

    if (this.bestTimeNotification > 0) {
      this.bestTimeNotification -= 1 / 60;
      if (this.bestTimeNotification < 0) {
        this.bestTimeNotification = 0;
      }
    }

    if (!menuOpen) {
      for (let orb of this.o) {
        if (orb.occupied) orb.eAngle += 0.05;
        if (orb.stunned > 0) {
          orb.stunned -= 1 / 60;
          if (orb.stunned < 0) orb.stunned = 0;
        }
        if (orb.shake > 0) orb.shake -= 1 / 60;
      }

      if (this.cycle > 0) {
        this.uStorms();

        if (this.RND() < 0.02 && this.storms.length < 3) {
          this.createStorm();
        }
      }
    }
  }

  checkComplete() {
    return this.o.filter((o) => o.occupied).length === this.o.length;
  }

  canEnter(orb, x, y) {
    if (orb.occupied || orb.stunned > 0.1) {
      return 0;
    }

    if (!this.followsElectronConfig(orb)) {
      return 0;
    }

    let dx = x - orb.x,
      dy = y - orb.y,
      dist = Math.sqrt(dx * dx + dy * dy);

    return dist < 25;
  }

  followsElectronConfig(targetOrb) {
    let s = {
      s1: this.o.filter((o) => o.shellR === 80),
      s2: this.o.filter((o) => o.shellR === 140 && o.type === 0),
      p2: this.o.filter((o) => o.shellR === 140 && o.type === 1),
    };

    let filled = {
      s1: s.s1.filter((o) => o.occupied).length,
      s2: s.s2.filter((o) => o.occupied).length,
      p2: s.p2.filter((o) => o.occupied).length,
    };

    if (targetOrb.shellR === 80) {
      return 1;
    }

    if (targetOrb.shellR === 140) {
      if (targetOrb.type === 0) {
        let allowed = filled.s1 >= s.s1.length;
        return allowed;
      }

      if (targetOrb.type === 1) {
        if (filled.s1 < s.s1.length) {
          return false;
        }

        if (targetOrb.occupied) {
          let empty2p = s.p2.filter((o) => !o.occupied);
          let allowed = empty2p.length === 0;
          return allowed;
        }
        return true;
      }
    }

    return true;
  }

  stun(orb, playSound = true) {
    orb.stunCount = (orb.stunCount || 0) + 1;
    let baseDuration = 3.0;
    let progressiveDuration = baseDuration + (orb.stunCount - 1) * 1.5;
    let maxDuration = 8.0;

    orb.stunned = Math.min(progressiveDuration, maxDuration);

    if (playSound && this.a?.c) {
      this.a.p(4, 0.4);
    }
  }

  hit(orb) {
    orb.hits = (orb.hits || 0) + 1;

    if (orb.hits >= 2) {
      let gameElectrons = this.gameRef ? this.gameRef.electrons : null;

      if (gameElectrons) {
        let electronToEject = null;

        for (let e of gameElectrons) {
          if (e.captured && e.type === orb.type) {
            electronToEject = e;
            break;
          }
        }

        if (electronToEject) {
          let angle = this.RND() * this.PI2;
          let distance = 60 + this.RND() * 20;

          let newX = orb.x + Math.cos(angle) * distance;
          let newY = orb.y + Math.sin(angle) * distance;

          newX = Math.max(50, Math.min(750, newX));
          newY = Math.max(50, Math.min(550, newY));

          electronToEject.x = newX;
          electronToEject.y = newY;

          let escapeSpeed = 2 + this.RND() * 1.5;
          electronToEject.vx = Math.cos(angle) * escapeSpeed;
          electronToEject.vy = Math.sin(angle) * escapeSpeed;

          electronToEject.inactive = 0.5;
          electronToEject.inactiveTime = 0.5;

          electronToEject.captured = 0;
          orb.occupied = 0;
        } else {
          if (this.gameRef && this.gameRef.respawn) {
            this.gameRef.respawn(orb.type);
          }
          orb.occupied = 0;
        }
      } else {
        orb.occupied = 0;
      }

      orb.hits = 0;
      orb.shake = 0;
      orb.stunned = 1.5;

      if (this.a?.c) {
        this.a.p(2, 0.5);
      }
    } else {
      orb.shake = 0.3;
      if (this.a?.c) {
        this.a.p(4, 0.4);
      }
    }
  }

  createStorm() {
    this.storms.push({
      x: 200 + Math.random() * 400,
      y: 150 + Math.random() * 300,
      r: 40,
      maxR: 100 + Math.random() * 60,
      life: 5 + Math.random() * 4,
      maxLife: 5 + Math.random() * 4,
      strength: 1.2 + Math.random() * 0.6,
      pulse: this.RND() * this.PI2,
    });
  }

  uStorms() {
    for (let i = this.storms.length - 1; i >= 0; i--) {
      let storm = this.storms[i];
      storm.life -= 1 / 60;
      storm.pulse += 0.1;

      let r = Math.max(0, Math.min(1, 1 - storm.life / storm.maxLife));
      storm.r = Math.max(10, 30 + (storm.maxR - 30) * Math.sin(r * 3.14));

      if (storm.life <= 0) {
        this.storms.splice(i, 1);
      }
    }
  }

  applyStormForces(electron) {
    if (!this.storms.length || electron.captured || electron.inactive > 0)
      return;

    for (let storm of this.storms) {
      let dx = electron.x - storm.x;
      let dy = electron.y - storm.y;
      let dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < storm.r && dist > 5) {
        let pulse = 0.7 + 0.3 * Math.sin(storm.pulse);
        let force = (storm.strength * pulse * (storm.r - dist)) / storm.r;
        let fx = (dx / dist) * force * 0.8;
        let fy = (dy / dist) * force * 0.8;

        electron.vx += fx;
        electron.vy += fy;
      }
    }
  }

  nextLevel() {
    if (this.checkComplete()) {
      this.tip = 0;
      this.completionDelay = 0;
      this.shellGlow = 0;
      this.l++;

      if (this.l >= this.L.length) {
        let runTime = (Date.now() - this.startTime) / 1000;

        let fastestTime = localStorage.getItem("fastestTime");
        if (!fastestTime || runTime < parseFloat(fastestTime)) {
          localStorage.setItem("fastestTime", runTime.toString());

          this.bestTimeNotification = 4.0;
          this.newBestTime = runTime;
        }

        this.cycle++;
        this.l = 0;
        this.storms = [];
        this.startTime = Date.now();
      }

      this.r();
      if (this.cycle > 0 && this.gameRef && this.gameRef.spawn) {
        this.gameRef.spawn();
      }

      return 1;
    }
    return 0;
  }

  d(ctx) {
    let colors = [
      [this.BLUE, "rgb(100,150,255)"],
      [this.ORANGE, "rgb(255,150,100)"],
    ];
    let lvl = this.L[this.l];
    let f = this.o.filter((o) => o.occupied).length;
    let total = this.o.length;
    let shells = new Set();
    for (let orb of this.o) {
      shells.add(orb.shellR);
    }
    ctx.save();
    if (this.shellGlow > 0) {
      ctx.shadowColor = `rgba(255,255,150,${this.shellGlow * 0.8})`;
      ctx.shadowBlur = 8;
      ctx.strokeStyle = `rgba(255,255,150,${this.shellGlow * 0.9})`;
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      [...shells].map((r) => {
        ctx.beginPath();
        ctx.arc(400, 300, r, 0, 6.28);
        ctx.stroke();
      });
      ctx.shadowBlur = 0;
    }
    ctx.strokeStyle = "rgba(100,150,200,.3)";
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    [...shells].map((r) => {
      ctx.beginPath();
      ctx.arc(400, 300, r, 0, 6.28);
      ctx.stroke();
    });
    ctx.setLineDash([]);
    ctx.restore();
    ctx.save();
    let fillRatio = total > 0 ? f / total : 0;
    let p = lvl[1];
    let n = Math.round(lvl[2] - lvl[1]);
    let nucleons = p + n;
    for (let s = 0; s < 8; s++) {
      let sparkleAngle = (s / 8) * 6.28 + this.t * 0.3;
      let sparkleR = 18 + Math.sin(this.t * 2 + s) * 6;
      let sx = 400 + Math.cos(sparkleAngle) * sparkleR;
      let sy = 300 + Math.sin(sparkleAngle) * sparkleR;
      let sparkleAlpha = 0.1 + 0.15 * Math.sin(this.t * 3 + s * 1.5);
      ctx.fillStyle = `rgba(255,255,200,${sparkleAlpha})`;
      ctx.beginPath();
      ctx.arc(sx, sy, 0.8, 0, 6.28);
      ctx.fill();
    }
    for (let i = 0; i < nucleons; i++) {
      let angle = (i / nucleons) * 6.28 + this.t * 0.08;
      let r = 2 + Math.sin(this.t * 0.4 + i) * 3;
      let x = 400 + Math.cos(angle) * r;
      let y = 300 + Math.sin(angle) * r;

      let pulse = 1 + fillRatio * 0.08 * Math.sin(this.t * 1.5 + i);
      let nucleonRadius = (3.5 + Math.sin(this.t * 1.2 + i) * 0.5) * pulse;

      let flowAlpha = 0.4 + 0.3 * Math.sin(this.t * 0.8 + i * 2);

      if (i < p) {
        let intensity = 0.5 + fillRatio * 0.2;
        ctx.fillStyle = `rgba(255,${60 * intensity},${
          60 * intensity
        },${flowAlpha})`;
      } else {
        let intensity = 0.5 + fillRatio * 0.2;
        ctx.fillStyle = `rgba(${60 * intensity},${
          100 * intensity
        },255,${flowAlpha})`;
      }
      ctx.beginPath();
      ctx.arc(x, y, nucleonRadius, 0, 6.28);
      ctx.fill();
    }
    ctx.restore();
    for (let orb of this.o) {
      ctx.save();
      let c = colors[orb.type];
      let stunned = orb.stunned > 0.1;
      let shakeX = 0,
        shakeY = 0;
      if (orb.shake > 0) {
        let shakeIntensity = orb.shake * 6;
        shakeX = (Math.random() - 0.5) * shakeIntensity;
        shakeY = (Math.random() - 0.5) * shakeIntensity;
      }
      if (stunned) {
        ctx.save();
        let warningPulse = 0.3 + 0.4 * Math.sin(this.t * 6);
        ctx.strokeStyle = `rgba(255,50,50,${warningPulse})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(orb.x + shakeX, orb.y + shakeY, 28, 0, 6.28);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
      ctx.strokeStyle = stunned ? "rgba(80,80,80,.4)" : c[0] + "0.8)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(orb.x + shakeX, orb.y + shakeY, 20, 0, 6.28);
      ctx.stroke();
      if (orb.occupied) {
        let ex = orb.x + shakeX + Math.cos(orb.eAngle) * 18;
        let ey = orb.y + shakeY + Math.sin(orb.eAngle) * 18;
        let eGrad = ctx.createRadialGradient(ex, ey, 0, ex, ey, 8);
        eGrad.addColorStop(0, c[1]);
        eGrad.addColorStop(1, c[1].replace("rgb", "rgba").replace(")", ",0)"));
        ctx.fillStyle = eGrad;
        ctx.beginPath();
        ctx.arc(ex, ey, 8, 0, 6.28);
        ctx.fill();
      } else {
        if (stunned) {
          let pulse = 0.2 + 0.3 * Math.sin(this.t * 4);
          ctx.fillStyle = `rgba(100,40,40,${pulse})`;
          ctx.beginPath();
          ctx.arc(orb.x + shakeX, orb.y + shakeY, 6, 0, 6.28);
          ctx.fill();
          ctx.strokeStyle = `rgba(255,80,80,${pulse})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(orb.x + shakeX - 4, orb.y + shakeY - 4);
          ctx.lineTo(orb.x + shakeX + 4, orb.y + shakeY + 4);
          ctx.moveTo(orb.x + shakeX + 4, orb.y + shakeY - 4);
          ctx.lineTo(orb.x + shakeX - 4, orb.y + shakeY + 4);
          ctx.stroke();
        } else {
          let pulse = 0.4 + 0.4 * Math.sin(this.t * 3);
          ctx.fillStyle = c[0] + `${pulse})`;
          ctx.beginPath();
          ctx.arc(orb.x + shakeX, orb.y + shakeY, 4, 0, 6.28);
          ctx.fill();
        }
      }
      ctx.restore();
    }
    for (let orb of this.o) {
      ctx.save();
      ctx.font = "10px monospace";
      ctx.fillStyle = "rgba(200,200,200,0.7)";
      ctx.textAlign = "center";
      if (orb.shellR === 80) {
        ctx.fillText("1s", orb.x, orb.y - 35);
      } else if (orb.shellR === 140) {
        if (orb.type === 0) {
          ctx.fillText("2s", orb.x, orb.y - 35);
        } else {
          ctx.fillText("2p", orb.x, orb.y - 35);
        }
      }
      ctx.restore();
    }
    for (let storm of this.storms) {
      ctx.save();
      let lifeRatio = storm.life / storm.maxLife;
      let alpha = Math.min(0.8, lifeRatio * 1.5);
      let pulse = 0.6 + 0.4 * Math.sin(storm.pulse);
      let radius = Math.max(5, storm.r);
      ctx.strokeStyle = `rgba(255,100,255,${alpha * 0.3})`;
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(storm.x, storm.y, radius, 0, 6.28);
      ctx.stroke();
      ctx.fillStyle = `rgba(255,150,255,${alpha * pulse * 0.5})`;
      ctx.beginPath();
      ctx.arc(storm.x, storm.y, Math.max(3, radius * 0.3 * pulse), 0, 6.28);
      ctx.fill();
      ctx.restore();
    }
    ctx.save();
    let boxX = 700,
      boxY = 20,
      boxW = 80,
      boxH = 80;
    ctx.fillStyle = "rgba(20,30,50,.9)";
    ctx.fillRect(boxX, boxY, boxW, boxH);
    ctx.strokeStyle = "rgba(100,200,255,.8)";
    ctx.lineWidth = 2;
    ctx.strokeRect(boxX, boxY, boxW, boxH);
    ctx.fillStyle = "rgba(100,200,255,.8)";
    ctx.font = "11px monospace";
    ctx.textAlign = "left";
    ctx.fillText(lvl[1], boxX + 5, boxY + 14);
    ctx.textAlign = "center";
    ctx.font = "26px monospace";
    ctx.fillStyle = "white";
    ctx.shadowColor = "rgba(100,200,255,.8)";
    ctx.shadowBlur = 10;
    ctx.fillText(lvl[3], boxX + boxW / 2, boxY + 40);
    ctx.shadowBlur = 0;
    ctx.font = "9px monospace";
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.fillText(lvl[0], boxX + boxW / 2, boxY + 55);
    ctx.font = "10px monospace";
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.fillText(lvl[2].toFixed(3), boxX + boxW / 2, boxY + 70);
    ctx.restore();
    ctx.save();
    ctx.textAlign = "left";
    ctx.font = "18px monospace";
    ctx.fillStyle = "white";
    ctx.shadowColor = "rgba(100,200,255,.6)";
    ctx.shadowBlur = 8;
    ctx.fillText(lvl[0], 20, 25);
    ctx.shadowBlur = 0;
    ctx.font = "12px monospace";
    ctx.fillStyle = "rgba(100,200,255,.8)";
    ctx.fillText(`Element ${lvl[3]} - Atomic #${lvl[1]}`, 20, 42);
    let runTime = (Date.now() - this.startTime) / 1000;
    ctx.textAlign = "left";
    ctx.font = "14px monospace";
    ctx.fillStyle = "rgba(220,230,240,.9)";
    ctx.fillText(`Run Time: ${runTime.toFixed(1)}s`, 20, 62);
    let fastestTime = localStorage.getItem("fastestTime");
    if (fastestTime) {
      ctx.fillStyle = "rgba(255,200,100,.9)";
      ctx.fillText(`Best Time: ${parseFloat(fastestTime).toFixed(1)}s`, 20, 80);
    }
    if (this.cycle > 0) {
      ctx.fillStyle = "rgba(255,150,100,.9)";
      ctx.fillText(`Cycle: ${this.cycle}`, 20, 98);
    }
    if (this.bestTimeNotification > 0) {
      ctx.save();
      let fadeTime = 0.5;
      let alpha = 1;
      if (this.bestTimeNotification < fadeTime) {
        alpha = this.bestTimeNotification / fadeTime;
      } else if (this.bestTimeNotification > 4.0 - fadeTime) {
        alpha = (4.0 - this.bestTimeNotification) / fadeTime;
      }
      let notifX = 300,
        notifY = 15,
        notifW = 200,
        notifH = 50;
      ctx.fillStyle = `rgba(20,30,50,${alpha * 0.95})`;
      ctx.fillRect(notifX, notifY, notifW, notifH);
      ctx.strokeStyle = `rgba(100,200,255,${alpha * 0.8})`;
      ctx.lineWidth = 2;
      ctx.strokeRect(notifX, notifY, notifW, notifH);
      ctx.font = "12px monospace";
      ctx.fillStyle = `rgba(255,255,255,${alpha * 0.9})`;
      ctx.textAlign = "center";
      ctx.fillText("⚡ NEW BEST TIME ⚡", notifX + notifW / 2, notifY + 20);
      ctx.font = "14px monospace";
      ctx.fillStyle = `rgba(100,200,255,${alpha})`;
      ctx.fillText(
        `${this.newBestTime.toFixed(1)}s`,
        notifX + notifW / 2,
        notifY + 37
      );
      ctx.restore();
    }
    if (this.tip) {
      ctx.save();
      let boxW = 450,
        boxH = 280,
        boxX = 175,
        boxY = 160;
      this.drawModal(ctx, boxX, boxY, boxW, boxH);
      let currentElement = this.L[this.l];
      this.drawStyledText(
        ctx,
        `${currentElement[0]} Complete!`,
        400,
        boxY + 40,
        "22px monospace",
        "rgb(255,200,100)",
        "rgb(255,150,100)",
        10
      );
      ctx.font = "16px monospace";
      ctx.fillStyle = "rgb(100,200,255)";
      const lines = this.F[this.l].split("\n");
      lines.forEach((line, i) => {
        ctx.fillText(line, 400, boxY + 75 + i * 20);
      });
      this.drawStyledText(
        ctx,
        `Symbol: ${currentElement[3]} • Atomic #: ${currentElement[1]} • Mass: ${currentElement[2]}`,
        400,
        boxY + 140,
        "14px monospace",
        "rgba(200,200,200,0.9)"
      );
      let statusText =
        this.l >= this.L.length - 1 && this.cycle === 0
          ? "🎉 Infinite Mode Unlocked! 🎉"
          : "Level Complete!";
      this.drawStyledText(
        ctx,
        statusText,
        400,
        boxY + 180,
        "18px monospace",
        "rgb(255,200,100)"
      );

      // Action prompt
      this.drawStyledText(
        ctx,
        "Click to continue to next level",
        400,
        boxY + 220,
        "14px monospace",
        "rgba(100,200,255,0.8)"
      );

      ctx.restore();
    }
  }
}


class A {
  constructor() {
    this.c = null;
    this.g = null;
    this.muted = 0;
    this.s = [];
  }

  async i() {
    if (this.c) return;
    this.c = new (AudioContext || webkitAudioContext)();
    this.g = this.c.createGain();
    this.g.gain.value = 0.3;
    this.g.connect(this.c.destination);

    this.delay = this.c.createDelay(0.5);
    this.delay.delayTime.value = 0.15;
    this.feedback = this.c.createGain();
    this.feedback.gain.value = 0.25;
    this.delay.connect(this.feedback);
    this.feedback.connect(this.delay);
    this.delay.connect(this.g);

    this.s = [
      this.b([1, 800, 0.3, 0.3, 0.002, 0.2]),
      this.b([1, 659, 0.35, 0.4, 0.005, 0.25]),
      this.b([2, 311, 0.25, 0.3, 0.002, 0.15]),
      this.b([1, 440, 0.25, 0.2, 0.01, 0.3]),
      this.b([1, 247, 0.2, 0.25, 0.002, 0.12]),
      this.b([1, 1175, 0.12, 0.15, 0.001, 0.08]),
      this.b([1, 698, 0.35, 0.4, 0.003, 0.25]),
      this.b([1, 523, 0.5, 0.5, 0.01, 0.3]),
      this.b([1, 1318, 0.4, 0.3, 0.002, 0.3]),
    ];
  }

  b(p) {
    const l = this.c.sampleRate * p[2];
    const buf = this.c.createBuffer(1, l, this.c.sampleRate);
    const d = buf.getChannelData(0);
    const a = p[4] * this.c.sampleRate;
    const r = (p[2] - p[5]) * this.c.sampleRate;

    for (let i = 0; i < l; i++) {
      let v;
      if (p[0] == 1) v = Math.sin((i * p[1] * 6.28) / this.c.sampleRate);
      else if (p[0] == 2) v = Math.random() * 2 - 1;
      else v = (((i * p[1] * 4) / this.c.sampleRate) % 2) - 1;

      let e = 1;
      if (i < a) e = i / a;
      else if (i > r) e = (l - i) / (l - r);

      d[i] = v * e * p[3];
    }
    return buf;
  }

  p(i, e, echo) {
    if (!this.c || this.muted) return;
    if (this.c.state === "suspended") {
      this.c.resume();
    }

    const now = Date.now();
    this.lastPlay = this.lastPlay || {};
    if (i !== 1 && this.lastPlay[i] && now - this.lastPlay[i] < 25) return;
    this.lastPlay[i] = now;

    const s = this.c.createBufferSource();
    const g = this.c.createGain();
    s.buffer = this.s[i];
    // Lowered default sound effect volume from 0.5 to 0.22
    g.gain.value = isFinite(e) ? e * 0.44 : 0.22;
    s.connect(g);
    g.connect(this.g);
    if (echo && this.delay) g.connect(this.delay);
    s.start();

    if (i === 1) {
      setTimeout(() => this.p(8, 0.6, true), 100);
    }
  }

  m() {
    if (!this.c) return;

    const chords = [
      [220, 264, 330],
      [175, 220, 262],
      [196, 247, 294],
      [196, 247, 294],
    ];

    const melodyNotes = [
      440, 392, 349, 330, 294, 330, 349, 392, 440, 523, 494, 440, 392, 349, 330,
      294,
    ];

    let chordIndex = 0;
    let melodyIndex = 0;

    const bass = this.c.createOscillator();
    const bassGain = this.c.createGain();
    bass.type = "sine";
    bass.frequency.value = 110;
    bassGain.gain.setValueAtTime(0, this.c.currentTime);
    bassGain.gain.linearRampToValueAtTime(0.03, this.c.currentTime + 4); // Increased from 0.006
    bass.connect(bassGain);
    bassGain.connect(this.g);
    bass.start();

    const chordOscs = [];
    for (let i = 0; i < 3; i++) {
      const osc = this.c.createOscillator();
      const gain = this.c.createGain();
      const filter = this.c.createBiquadFilter();

      osc.type = "triangle";
      filter.type = "lowpass";
      filter.frequency.value = 600;
      filter.Q.value = 0.7;

      gain.gain.setValueAtTime(0, this.c.currentTime);
      gain.gain.linearRampToValueAtTime(0.04, this.c.currentTime + 3 + i); // Increased from 0.008

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(this.g);
      osc.start();

      chordOscs.push({ osc, gain });
    }

    const melody = this.c.createOscillator();
    const melodyGain = this.c.createGain();
    const melodyFilter = this.c.createBiquadFilter();

    melody.type = "sine";
    melodyFilter.type = "lowpass";
    melodyFilter.frequency.value = 1200;
    melodyGain.gain.setValueAtTime(0, this.c.currentTime);

    melody.connect(melodyFilter);
    melodyFilter.connect(melodyGain);
    melodyGain.connect(this.g);
    if (this.delay) melodyGain.connect(this.delay);
    melody.start();

    const changeChord = () => {
      const currentChord = chords[chordIndex];

      if (bass.frequency) {
        const bassNote = currentChord[0] / 2;
        bass.frequency.exponentialRampToValueAtTime(
          bassNote,
          this.c.currentTime + 1
        );
      }

      chordOscs.forEach((voice, i) => {
        if (voice.osc.frequency) {
          voice.osc.frequency.exponentialRampToValueAtTime(
            currentChord[i],
            this.c.currentTime + 1.5
          );
        }
      });

      chordIndex = (chordIndex + 1) % chords.length;
      setTimeout(changeChord, 8000);
    };

    const playMelodyNote = () => {
      const note = melodyNotes[melodyIndex];

      if (melody.frequency) {
        melodyGain.gain.cancelScheduledValues(this.c.currentTime);
        melodyGain.gain.setValueAtTime(0, this.c.currentTime);
        melodyGain.gain.linearRampToValueAtTime(0.02, this.c.currentTime + 0.3); // Increased from 0.004
        melodyGain.gain.linearRampToValueAtTime(0.008, this.c.currentTime + 2);

        melody.frequency.exponentialRampToValueAtTime(
          note,
          this.c.currentTime + 0.1
        );
      }

      melodyIndex = (melodyIndex + 1) % melodyNotes.length;
      setTimeout(playMelodyNote, 2500 + Math.random() * 1000);
    };

    setTimeout(changeChord, 4000);
    setTimeout(playMelodyNote, 6000);
  }

  t() {
    this.muted = !this.muted;
    this.g.gain.value = this.muted ? 0 : 0.3;
    return this.muted;
  }
}


class G {
  constructor() {
    this.c = document.getElementById("gameCanvas");
    this.ctx = this.c.getContext("2d");

    this.audio = new A();

    this.input = { mouse: { x: 400, y: 300 } };
    this.c.addEventListener("mousemove", async (e) => {
      let rect = this.c.getBoundingClientRect();
      this.input.mouse.x = e.clientX - rect.left;
      this.input.mouse.y = e.clientY - rect.top;

      // Try to initialize audio on any mouse movement
      if (!this.audio.c) {
        try {
          await this.audio.i();
          this.audio.m();
        } catch (err) {}
      }
    });

    this.c.addEventListener("mousedown", async () => {
      if (!this.audio.c) {
        await this.audio.i();
        this.audio.m();
      }
    });

    this.o = new O(this.c, this.audio, this);
    this.tutorial = new T(this);

    this.electrons = [];
    this.particles = [];

    this.spawn();
    this.spawnParticles();

    this.c.addEventListener("click", async (e) => {
      if (this.o.tip) {
        this.o.tip = 0;
        this.audio.p(5, 0.6);
        if (this.o.checkComplete()) {
          this.o.nextLevel();
          this.spawn();
        }
        return;
      }
      if (this.o.completionDelay > 0) {
        return;
      }
      if (this.o.checkComplete()) {
        this.o.nextLevel();
        this.spawn();
      }
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (this.o.tip) {
          this.o.tip = 0;
        } else {
          this.tutorial.v ? this.tutorial.hide() : this.tutorial.show();
        }
      } else if (e.key === "m" || e.key === "M") {
        this.audio.t();
      }
    });

    this.loop();

    setTimeout(() => {
      if (this.tutorial.shouldShow()) this.tutorial.show();
    }, 1000);
  }

  spawn() {
    this.electrons = [];
    let types = [0, 1];
    types.forEach((type) => {
      let count = this.o.o.filter((o) => o.type === type).length;
      for (let i = 0; i < count; i++) {
        let x,
          y,
          attempts = 0;
        do {
          x = Math.random() * (this.c.width - 200) + 100;
          y = Math.random() * (this.c.height - 200) + 100;
          attempts++;
        } while (attempts < 10 && this.nearOrbital(x, y, 60));

        this.electrons.push(new E(x, y, type, this.audio));
      }
    });
  }

  respawn(type) {
    let x,
      y,
      attempts = 0;
    do {
      x = Math.random() * (this.c.width - 200) + 100;
      y = Math.random() * (this.c.height - 200) + 100;
      attempts++;
    } while (attempts < 10 && this.nearOrbital(x, y, 60));

    let e = new E(x, y, type, this.audio);
    e.vx = (Math.random() - 0.5) * 3;
    e.vy = (Math.random() - 0.5) * 3;
    this.electrons.push(e);
  }

  nearOrbital(x, y, minDist) {
    return this.o.o.some((o) => {
      let dx = x - o.x,
        dy = y - o.y;
      return Math.sqrt(dx * dx + dy * dy) < minDist;
    });
  }

  spawnParticles() {
    this.particles = [];
    for (let i = 0; i < 20; i++) {
      this.particles.push({
        x: Math.random() * this.c.width,
        y: Math.random() * this.c.height,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        alpha: Math.random() * 0.4 + 0.1,
        phase: Math.random() * 6.28,
        size: Math.random() * 1.5 + 0.5,
      });
    }
  }

  update() {
    this.o.u();

    for (let p of this.particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.phase += 0.02;

      if (p.x < 0) p.x = this.c.width;
      if (p.x > this.c.width) p.x = 0;
      if (p.y < 0) p.y = this.c.height;
      if (p.y > this.c.height) p.y = 0;
    }

    for (let e of this.electrons) {
      e.u(this.input.mouse, this.o.o, this);

      this.o.applyStormForces(e);
    }
  }

  draw() {
    this.ctx.fillStyle = "rgb(10,10,20)";
    this.ctx.fillRect(0, 0, this.c.width, this.c.height);

    this.ctx.save();
    for (let p of this.particles) {
      let twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(p.phase));
      this.ctx.fillStyle = `rgba(200,220,255,${p.alpha * twinkle})`;
      this.ctx.beginPath();
      this.ctx.arc(p.x, p.y, p.size, 0, 6.28);
      this.ctx.fill();
    }
    this.ctx.restore();

    if (!this.o.tip) {
      let ctx = this.ctx;
      ctx.save();
      ctx.translate(this.input.mouse.x, this.input.mouse.y);

      let time = Date.now() * 0.003;

      ctx.shadowColor = "rgba(0,255,255,0.9)";
      ctx.shadowBlur = 12;
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.beginPath();
      ctx.arc(0, 0, 5 + Math.sin(time) * 0.8, 0, 6.28);
      ctx.fill();
      ctx.shadowBlur = 0;

      ctx.strokeStyle = "rgba(0,255,255,0.8)";
      ctx.lineWidth = 1.5;
      for (let i = 0; i < 8; i++) {
        let baseAngle = (time * 0.5 + i * 1.3) % 6.28;
        let randomOffset =
          Math.sin(time * 3 + i * 2.7) * 0.8 + (Math.random() - 0.5) * 1.2;
        let angle = baseAngle + randomOffset;

        let length = 4 + Math.random() * 6 + Math.sin(time * 2 + i) * 2;

        ctx.beginPath();
        ctx.moveTo(0, 0);

        let segments = 2 + Math.floor(Math.random() * 2);
        let x = 0,
          y = 0;

        for (let seg = 0; seg < segments; seg++) {
          let segmentLength = length / segments;
          let segmentAngle = angle + (Math.random() - 0.5) * 0.4;
          x += Math.cos(segmentAngle) * segmentLength;
          y += Math.sin(segmentAngle) * segmentLength;
          ctx.lineTo(x, y);
        }

        ctx.stroke();
      }

      ctx.restore();
    }

    this.o.d(this.ctx);

    if (!this.o.tip) {
      for (let e of this.electrons) {
        e.d(this.ctx);
      }
    }

    this.ctx.fillStyle = "rgba(255,255,255,.7)";
    this.ctx.font = "12px monospace";
    this.ctx.fillText(
      "Blue (s) attracted to cursor, Orange (p) repelled | M:Mute ESC:Tutorial",
      20,
      580
    );

    // Bottom right - Level info with infinite level support
    this.ctx.textAlign = "right";
    this.ctx.fillStyle = "rgba(100, 200, 255, 0.8)";
    this.ctx.font = "14px monospace";

    // Calculate total levels completed across all cycles
    let totalLevelsCompleted = this.o.cycle * this.o.L.length + this.o.l + 1;

    if (this.o.cycle > 0) {
      this.ctx.fillText(`Level: ${totalLevelsCompleted}`, 780, 580);
    } else {
      this.ctx.fillText(`Level: ${this.o.l + 1}/${this.o.L.length}`, 780, 580);
    }

    this.ctx.textAlign = "left";
  }

  loop() {
    this.update();
    this.draw();
    requestAnimationFrame(() => this.loop());
  }

  hit(orb) {
    this.o.gameRef = this;
    this.o.hit(orb);
  }

  stun(orb, playSound) {
    this.o.stun(orb, playSound);
  }

  canEnter(orb, x, y) {
    return this.o.canEnter(orb, x, y);
  }
}



// Initialize the golfed game
window.game = new G();
window.tutorial = window.game.tutorial; // Make tutorial globally accessible
  </script>
    <script>
      window.game = new G();
      window.tutorial = window.game.tutorial;
    </script>
  </body>
</html>
