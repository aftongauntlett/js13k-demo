<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mystic Grove - js13k Game</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #0a1628;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: Arial, sans-serif;
      }

      canvas {
        border: 1px solid rgba(255, 255, 255, 0.1);
        cursor: crosshair;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #64ffda;
        font-size: 12px;
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">Mystic Grove - Guide fireflies to form constellations</div>

    <script>
// Firefly particle with sparkle effects
class Firefly {
  constructor(canvas, colors) {
    this.canvas = canvas;
    this.colors = colors;
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.vx = (Math.random() - 0.5) * 0.5;
    this.vy = (Math.random() - 0.5) * 0.5;
    this.size = Math.random() * 1.5 + 1;
    this.brightness = Math.random() * 0.4 + 0.3;
    this.phase = Math.random() * Math.PI * 2;
    this.color =
      Math.random() > 0.7
        ? colors.warm
        : Math.random() > 0.4
        ? colors.glow
        : colors.accent;

    // Sparkle particles around each firefly
    this.sparkles = [];
    for (let i = 0; i < 6; i++) {
      this.sparkles.push({
        angle: ((Math.PI * 2) / 6) * i,
        distance: Math.random() * 15 + 10,
        phase: Math.random() * Math.PI * 2,
        speed: Math.random() * 0.02 + 0.01,
        brightness: Math.random() * 0.6 + 0.2,
      });
    }
  }

  update(mouse) {
    // Gentle floating movement
    this.x += this.vx;
    this.y += this.vy;

    // Mouse interaction - fireflies are attracted but also repelled at close range
    const dx = mouse.x - this.x;
    const dy = mouse.y - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance < 100) {
      // Close range - gentle repulsion
      const force = (100 - distance) / 1000;
      this.vx -= (dx / distance) * force;
      this.vy -= (dy / distance) * force;
    } else if (distance < 200) {
      // Medium range - gentle attraction
      const force = 0.0005;
      this.vx += (dx / distance) * force;
      this.vy += (dy / distance) * force;
    }

    // Limit velocity
    this.vx *= 0.98;
    this.vy *= 0.98;

    // Wrap around edges
    if (this.x < 0) this.x = this.canvas.width;
    if (this.x > this.canvas.width) this.x = 0;
    if (this.y < 0) this.y = this.canvas.height;
    if (this.y > this.canvas.height) this.y = 0;

    // Update pulsing phase
    this.phase += 0.02;

    // Update sparkle particles
    this.sparkles.forEach((sparkle) => {
      sparkle.phase += sparkle.speed;
      sparkle.angle += 0.005; // Slow rotation
    });
  }

  draw(ctx) {
    const pulse = Math.sin(this.phase) * 0.3 + 0.7;
    const alpha = this.brightness * pulse;

    ctx.save();

    // Draw sparkle particles first (behind firefly)
    this.sparkles.forEach((sparkle) => {
      const sparkleAlpha = Math.sin(sparkle.phase) * 0.5 + 0.5;
      const sparkleX = this.x + Math.cos(sparkle.angle) * sparkle.distance;
      const sparkleY = this.y + Math.sin(sparkle.angle) * sparkle.distance;

      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = `rgba(255, 255, 255, ${
        sparkleAlpha * sparkle.brightness * 0.4
      })`;
      ctx.beginPath();
      ctx.arc(sparkleX, sparkleY, 0.5, 0, Math.PI * 2);
      ctx.fill();

      // Tiny glow around sparkle
      const sparkleGlow = ctx.createRadialGradient(
        sparkleX,
        sparkleY,
        0,
        sparkleX,
        sparkleY,
        3
      );
      sparkleGlow.addColorStop(
        0,
        `rgba(255, 255, 255, ${sparkleAlpha * 0.2})`
      );
      sparkleGlow.addColorStop(1, "rgba(255, 255, 255, 0)");
      ctx.fillStyle = sparkleGlow;
      ctx.beginPath();
      ctx.arc(sparkleX, sparkleY, 3, 0, Math.PI * 2);
      ctx.fill();
    });

    // Outer soft glow
    ctx.globalCompositeOperation = "screen";
    const outerGlow = ctx.createRadialGradient(
      this.x,
      this.y,
      0,
      this.x,
      this.y,
      this.size * 8
    );
    outerGlow.addColorStop(0, `rgba(${this.color}, ${alpha * 0.08})`);
    outerGlow.addColorStop(0.5, `rgba(${this.color}, ${alpha * 0.03})`);
    outerGlow.addColorStop(1, `rgba(${this.color}, 0)`);

    ctx.fillStyle = outerGlow;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * 8, 0, Math.PI * 2);
    ctx.fill();

    // Middle glow
    const middleGlow = ctx.createRadialGradient(
      this.x,
      this.y,
      0,
      this.x,
      this.y,
      this.size * 4
    );
    middleGlow.addColorStop(0, `rgba(${this.color}, ${alpha * 0.15})`);
    middleGlow.addColorStop(0.7, `rgba(${this.color}, ${alpha * 0.05})`);
    middleGlow.addColorStop(1, `rgba(${this.color}, 0)`);

    ctx.fillStyle = middleGlow;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * 4, 0, Math.PI * 2);
    ctx.fill();

    // Inner bright core
    ctx.globalCompositeOperation = "lighter";
    const coreGlow = ctx.createRadialGradient(
      this.x,
      this.y,
      0,
      this.x,
      this.y,
      this.size * pulse * 2
    );
    coreGlow.addColorStop(0, `rgba(${this.color}, ${alpha * 0.4})`);
    coreGlow.addColorStop(0.6, `rgba(${this.color}, ${alpha * 0.2})`);
    coreGlow.addColorStop(1, `rgba(${this.color}, 0)`);

    ctx.fillStyle = coreGlow;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size * pulse * 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}


// Rendering system for backgrounds and effects
class Renderer {
  constructor(canvas, ctx, colors) {
    this.canvas = canvas;
    this.ctx = ctx;
    this.colors = colors;
    this.time = 0;
  }

  drawBackground(mouse) {
    // Create radial gradient from center
    const gradient = this.ctx.createRadialGradient(
      this.canvas.width / 2,
      this.canvas.height / 2,
      0,
      this.canvas.width / 2,
      this.canvas.height / 2,
      Math.max(this.canvas.width, this.canvas.height) * 0.7
    );

    gradient.addColorStop(0, `rgb(${this.colors.bg3})`);
    gradient.addColorStop(0.4, `rgb(${this.colors.bg2})`);
    gradient.addColorStop(1, `rgb(${this.colors.bg1})`);

    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // Add subtle mouse-following light
    const mouseGradient = this.ctx.createRadialGradient(
      mouse.x,
      mouse.y,
      0,
      mouse.x,
      mouse.y,
      150
    );

    mouseGradient.addColorStop(0, `rgba(${this.colors.glow}, 0.05)`);
    mouseGradient.addColorStop(1, `rgba(${this.colors.glow}, 0)`);

    this.ctx.fillStyle = mouseGradient;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }

  drawCenterGlow() {
    const pulse = Math.sin(this.time * 0.02) * 0.3 + 0.7;

    // Center glow
    this.ctx.save();
    this.ctx.globalCompositeOperation = "screen";

    const centerGlow = this.ctx.createRadialGradient(
      this.canvas.width / 2,
      this.canvas.height / 2,
      0,
      this.canvas.width / 2,
      this.canvas.height / 2,
      100 * pulse
    );

    centerGlow.addColorStop(0, `rgba(${this.colors.purple}, 0.3)`);
    centerGlow.addColorStop(0.5, `rgba(${this.colors.accent}, 0.1)`);
    centerGlow.addColorStop(1, `rgba(${this.colors.accent}, 0)`);

    this.ctx.fillStyle = centerGlow;
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    this.ctx.restore();
  }

  clear() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }

  update() {
    this.time++;
  }
}


// Input handling system
class InputSystem {
  constructor(canvas) {
    this.canvas = canvas;
    this.mouse = { x: canvas.width / 2, y: canvas.height / 2 };
    this.keyCallbacks = new Map();

    this.setupEventListeners();
  }

  setupEventListeners() {
    this.canvas.addEventListener("mousemove", (e) => {
      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = e.clientX - rect.left;
      this.mouse.y = e.clientY - rect.top;
    });

    // Keyboard event listener
    document.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if (this.keyCallbacks.has(key)) {
        e.preventDefault();
        this.keyCallbacks.get(key)();
      }
    });
  }

  // Register a callback for a specific key
  onKey(key, callback) {
    this.keyCallbacks.set(key.toLowerCase(), callback);
  }

  getMouse() {
    return this.mouse;
  }
}


// Main game class
class Game {
  constructor() {
    this.canvas = document.getElementById("gameCanvas");
    this.ctx = this.canvas.getContext("2d");

    // Color palette
    this.colors = {
      bg1: "10, 22, 40", // Deep teal-blue
      bg2: "26, 35, 50", // Slightly lighter
      bg3: "42, 51, 66", // Mid tone
      accent: "74, 144, 255", // Bright blue glow
      warm: "255, 140, 66", // Burnt orange
      sage: "135, 169, 107", // Muted sage
      purple: "107, 70, 193", // Deep purple
      glow: "100, 255, 218", // Cyan glow
    };

    // Initialize systems
    this.renderer = new Renderer(this.canvas, this.ctx, this.colors);
    this.input = new InputSystem(this.canvas);
    this.constellations = new ConstellationSystem(this.canvas, this.colors);

    // Set up pattern change callback
    this.constellations.onPatternChange = () => {
      this.initializeFireflies();
    };

    // Initialize fireflies - adjust count based on current pattern
    this.fireflies = [];
    this.initializeFireflies();

    // Set up test controls
    this.setupTestControls();

    console.log(
      "Mystic Grove initialized! Guide the fireflies to form constellations."
    );
  }

  setupTestControls() {
    // N = Next pattern
    this.input.onKey("n", () => {
      this.constellations.switchToNextPattern();
    });

    // P = Previous pattern
    this.input.onKey("p", () => {
      this.constellations.switchToPreviousPattern();
    });

    // C = Complete current pattern (for testing)
    this.input.onKey("c", () => {
      this.constellations.onPatternCompleted();
    });

    // R = Reset game
    this.input.onKey("r", () => {
      this.constellations.resetGame();
      this.initializeFireflies(); // Still need this since resetGame doesn't trigger callback
    });
  }

  initializeFireflies() {
    // Clear existing fireflies
    this.fireflies = [];

    // Create enough fireflies for the current pattern (plus some extras)
    const pattern = this.constellations.getCurrentPattern();
    // Give extra fireflies for the Star pattern since it has 10 targets
    const baseExtra = pattern.name === "Star" ? 5 : 3;
    const fireflyCount = Math.max(pattern.targets.length + baseExtra, 8);

    for (let i = 0; i < fireflyCount; i++) {
      this.fireflies.push(new Firefly(this.canvas, this.colors));
    }

    console.log(
      `${pattern.name}: Created ${fireflyCount} fireflies for ${pattern.targets.length} targets`
    );
  }

  update() {
    const mouse = this.input.getMouse();

    // Update fireflies
    this.fireflies.forEach((firefly) => {
      firefly.update(mouse);
    });

    // Update constellation system
    this.constellations.update();

    // Check for pattern completion
    this.constellations.checkPatternCompletion(this.fireflies);

    // Update renderer
    this.renderer.update();
  }

  render() {
    const mouse = this.input.getMouse();

    // Clear canvas
    this.renderer.clear();

    // Draw atmospheric background
    this.renderer.drawBackground(mouse);

    // Draw center glow effect
    this.renderer.drawCenterGlow();

    // Draw constellation targets
    this.constellations.drawTargets(this.ctx);

    // Draw fireflies
    this.fireflies.forEach((firefly) => {
      firefly.draw(this.ctx);
    });

    // Draw constellation connections (if pattern complete)
    this.constellations.drawConnections(this.ctx, this.fireflies);

    // Draw UI (score, instructions, etc.)
    this.constellations.drawUI(this.ctx);
  }

  gameLoop() {
    this.update();
    this.render();
    requestAnimationFrame(() => this.gameLoop());
  }

  start() {
    this.gameLoop();
  }
}


// Start the game
const game = new Game();
game.start();
</script>
  </body>
</html>
