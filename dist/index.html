<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atomic Puzzle Game - js13k Demo</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #020408; /* Very dark laboratory background */
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: "Courier New", monospace; /* Scientific/technical font */
      }

      canvas {
        border: 1px solid rgba(100, 150, 255, 0.2); /* Subtle blue glow */
        cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="12" fill="none" stroke="rgba(100,150,255,0.8)" stroke-width="2"/><circle cx="16" cy="16" r="6" fill="none" stroke="rgba(100,150,255,0.6)" stroke-width="1"/><circle cx="16" cy="16" r="2" fill="rgba(100,150,255,0.9)"/><line x1="4" y1="16" x2="12" y2="16" stroke="rgba(100,150,255,0.7)" stroke-width="1"/><line x1="20" y1="16" x2="28" y2="16" stroke="rgba(100,150,255,0.7)" stroke-width="1"/><line x1="16" y1="4" x2="16" y2="12" stroke="rgba(100,150,255,0.7)" stroke-width="1"/><line x1="16" y1="20" x2="16" y2="28" stroke="rgba(100,150,255,0.7)" stroke-width="1"/></svg>')
            16 16,
          crosshair;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #96c8ff; /* Scientific blue */
        font-size: 12px;
        opacity: 0.8;
        font-family: "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">
      Atomic Puzzle Game - Guide electrons to matching colored orbitals
    </div>

    <script>
// Simple electron with polarity-based physics
class Electron {
  constructor(x, y, type, audioSystem = null) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = (Math.random() - 0.5) * 2;
    this.type = type; // 'blue', 'orange', or 'grey'
    this.originalType = type; // Store original type for recovery
    this.radius = 8;
    this.captured = false;
    this.mouseInfluenced = false;
    this.inactive = false; // True when electron becomes grey/inactive
    this.inactiveTime = 0; // Time remaining inactive
    this.TAU = Math.PI * 2; // 2π constant for efficiency
    this.audio = audioSystem; // Reference to audio system
  }

  // Handle boundary collisions for all scenarios
  handleBoundaries(canvasWidth, canvasHeight) {
    // UI collision boundaries - invisible walls around text areas
    // Top-left UI area (level, score, timer)
    if (this.x < 220 && this.y < 120) {
      if (this.x < 220 && this.y > 110) {
        // Bottom edge of UI area
        this.y = 120;
        this.vy = Math.abs(this.vy);
      } else if (this.x > 210 && this.y < 120) {
        // Right edge of UI area
        this.x = 220;
        this.vx = Math.abs(this.vx);
      }
    }

    // Bottom instruction text area
    if (this.y > canvasHeight - 50) {
      this.y = canvasHeight - 50;
      this.vy = -Math.abs(this.vy);
    }

    // Canvas boundaries
    if (this.x < this.radius) {
      this.x = this.radius;
      this.vx = Math.abs(this.vx);
    }
    if (this.x > canvasWidth - this.radius) {
      this.x = canvasWidth - this.radius;
      this.vx = -Math.abs(this.vx);
    }
    if (this.y < this.radius) {
      this.y = this.radius;
      this.vy = Math.abs(this.vy);
    }
    if (this.y > canvasHeight - this.radius) {
      this.y = canvasHeight - this.radius;
      this.vy = -Math.abs(this.vy);
    }
  }

  update(mouseX, mouseY, orbitals, orbitalSystem) {
    if (this.captured) return;

    const M = Math; // Shorter reference for size optimization

    // Handle inactive electron recovery
    if (this.inactive) {
      this.inactiveTime -= 1 / 60; // Decrease by 1/60th second (assuming 60fps)
      if (this.inactiveTime <= 0) {
        // Reactivate electron
        this.inactive = false;
        this.type = this.originalType;
      } else {
        // Still inactive, just update physics but no mouse interaction
        this.vx *= 0.98;
        this.vy *= 0.98;
        this.x += this.vx;
        this.y += this.vy;

        // Use shared boundary handling
        this.handleBoundaries(
          orbitalSystem.canvas.width,
          orbitalSystem.canvas.height
        );
        return;
      }
    }

    let dx = this.x - mouseX,
      dy = this.y - mouseY;
    let distance = M.sqrt(dx * dx + dy * dy);

    // Track if mouse is close enough to influence electron (only if not inactive)
    this.mouseInfluenced = distance < 150;

    if (distance > 0 && this.mouseInfluenced) {
      let force = this.type === "blue" ? -0.15 : 0.15;
      this.vx += (dx / distance) * force;
      this.vy += (dy / distance) * force;
    }

    this.vx *= 0.98;
    this.vy *= 0.98;
    this.x += this.vx;
    this.y += this.vy;

    // Play subtle gliding sound based on velocity (only when moving fast enough)
    let velocity = M.sqrt(this.vx * this.vx + this.vy * this.vy);
    if (velocity > 2 && this.audio && M.random() < 0.03) {
      // 3% chance per frame when moving fast
      this.audio.playOrbitalGlide(velocity / 10); // Normalize velocity for sound intensity
    }

    // Get canvas bounds from orbital system
    let canvasWidth = orbitalSystem.canvas.width;
    let canvasHeight = orbitalSystem.canvas.height;

    // Handle all boundary collisions
    this.handleBoundaries(canvasWidth, canvasHeight);

    // Orbital interactions
    for (let orbital of orbitals) {
      let odx = this.x - orbital.x,
        ody = this.y - orbital.y;
      let odist = M.sqrt(odx * odx + ody * ody);

      if (odist < orbital.radius + this.radius) {
        if (orbital.occupied && !this.inactive) {
          // Hit an occupied orbital - trigger shake/knockout
          let electronKnockedOut = orbitalSystem.hitOccupiedOrbital(orbital);

          if (electronKnockedOut) {
            // Play knock out sound
            if (this.audio) {
              this.audio.playElectronKnockedOut();
            }

            // Create a new electron to replace the knocked-out one
            // Spawn it near the orbital but with some random velocity
            let newElectron = new Electron(
              orbital.x + (M.random() - 0.5) * 100,
              orbital.y + (M.random() - 0.5) * 100,
              orbital.type,
              this.audio
            );
            // Add some initial velocity to the new electron
            newElectron.vx = (M.random() - 0.5) * 4;
            newElectron.vy = (M.random() - 0.5) * 4;

            // Add the new electron to the game
            // We need access to the electrons array from the game instance
            // For now, we'll store it in a way the game can pick it up
            if (window.game) {
              window.game.electrons.push(newElectron);
            }
          } else {
            // Just a collision, not a knockout
            if (this.audio) {
              this.audio.playOrbitalCollision();
            }
          }

          // Bounce away from orbital
          let bounceX = odx / odist,
            bounceY = ody / odist;
          this.vx = bounceX * 3;
          this.vy = bounceY * 3;
          this.x = orbital.x + bounceX * (orbital.radius + this.radius + 2);
          this.y = orbital.y + bounceY * (orbital.radius + this.radius + 2);
        } else if (orbital.type === this.type) {
          // Correct color orbital
          if (!orbital.occupied) {
            // Check if electron can enter this orbital (considers rotation gaps)
            if (
              this.mouseInfluenced &&
              orbitalSystem.canEnterOrbital(orbital, this.x, this.y)
            ) {
              // Electron can enter - capture it
              orbital.occupied = true;
              this.captured = true;
              this.x = orbital.x;
              this.y = orbital.y;

              // Play capture sound
              if (this.audio) {
                this.audio.playElectronCapture();
              }

              break;
            } else if (orbital.rotate) {
              // Rotating orbital but electron can't enter through gap - bounce
              let bounceX = odx / odist,
                bounceY = ody / odist;
              this.vx = bounceX * 3;
              this.vy = bounceY * 3;
              this.x = orbital.x + bounceX * (orbital.radius + this.radius + 2);
              this.y = orbital.y + bounceY * (orbital.radius + this.radius + 2);
            }
          }
        } else if (!orbital.occupied && !this.inactive) {
          // Wrong color orbital - make electron inactive and stun orbital
          this.inactive = true;
          this.type = "grey";
          this.mouseInfluenced = false;
          this.inactiveTime = 5; // Inactive for 5 seconds
          orbitalSystem.stunOrbital(orbital);

          // Play wrong electron sound
          if (this.audio) {
            this.audio.playWrongElectron();
          }

          // Bounce away from orbital
          let bounceX = odx / odist,
            bounceY = ody / odist;
          this.vx = bounceX * 3;
          this.vy = bounceY * 3;
          this.x = orbital.x + bounceX * (orbital.radius + this.radius + 2);
          this.y = orbital.y + bounceY * (orbital.radius + this.radius + 2);
        }
      }
    }
  }

  draw(ctx) {
    if (this.captured) return;

    const M = Math; // Shorter reference for size optimization
    ctx.save();

    // Color map for electrons
    const colors = {
      blue: ["rgba(100,150,255,0.8)", "rgb(150,200,255)", "rgb(100,150,255)"],
      orange: ["rgba(255,150,100,0.8)", "rgb(255,200,150)", "rgb(255,150,100)"],
    };

    // Add subtle glow when mouse-influenced (but not if inactive)
    if (this.mouseInfluenced && !this.inactive) {
      ctx.shadowColor = colors[this.type]
        ? colors[this.type][0]
        : "rgba(128,128,128,0.8)";
      ctx.shadowBlur = 15;
    }

    let grad = ctx.createRadialGradient(
      this.x,
      this.y,
      0,
      this.x,
      this.y,
      this.radius
    );

    if (colors[this.type]) {
      let c = colors[this.type];
      grad.addColorStop(0, c[1]);
      grad.addColorStop(1, c[2]);
    } else {
      // Grey/inactive electron with recovery indicator
      if (this.inactive && this.inactiveTime > 0) {
        // Add pulsing effect as it recovers
        let pulse = 0.5 + 0.3 * M.sin(Date.now() * 0.01);
        grad.addColorStop(0, `rgba(180,180,180,${pulse})`);
        grad.addColorStop(1, `rgba(120,120,120,${pulse * 0.7})`);
      } else {
        grad.addColorStop(0, "rgb(180,180,180)");
        grad.addColorStop(1, "rgb(120,120,120)");
      }
    }

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, this.TAU);
    ctx.fill();
    ctx.restore();
  }
}


// Tutorial overlay system for explaining game mechanics and electron physics
class Tutorial {
  constructor(game) {
    this.game = game;
    this.isVisible = false;
    this.currentStep = 0;
    this.totalSteps = 4;
    this.overlay = null;
    this.hasBeenShown = localStorage.getItem("atomicTutorialShown") === "true";

    this.steps = [
      {
        title: "Welcome to Atomic Assembly!",
        content: `
          <div class="tutorial-content">
            <h3>Learn Real Atomic Physics!</h3>
            <p>You'll build atoms by placing electrons in their correct orbitals, learning how real atoms work!</p>
            <div class="physics-key">
              <h4>Your Mission:</h4>
              <p>- Each level shows a real chemical element (H, He, Li, C, N)</p>
              <p>- Place electrons in the correct orbital positions</p>
              <p>- Learn about electron spins and quantum mechanics!</p>
            </div>
          </div>
        `,
        buttonText: "Continue",
      },
      {
        title: "Understanding Electron Spins",
        content: `
          <div class="tutorial-content">
            <h3>The Science Behind the Colors</h3>
            <div class="spin-explanation">
              <div class="spin-demo">
                <div class="orb blue-orb"></div>
                <div class="spin-label">
                  <strong>Blue Orbs = Spin-Down <div class="orb-inline blue-orb"></div></strong><br>
                  <small>Electrons spinning in one direction</small>
                </div>
              </div>
              <div class="spin-demo">
                <div class="orb orange-orb"></div>
                <div class="spin-label">
                  <strong>Orange Orbs = Spin-Up <div class="orb-inline orange-orb"></div></strong><br>
                  <small>Electrons spinning in the opposite direction</small>
                </div>
              </div>
            </div>
            <p class="physics-fact">
              <strong>Real Physics:</strong> Electrons have a quantum property called "spin". 
              Each orbital can hold up to 2 electrons, but they must have opposite spins. 
              Some atoms like Hydrogen have only 1 electron, leaving orbitals half-filled.
            </p>
          </div>
        `,
        buttonText: "Continue",
      },
      {
        title: "How to Play",
        content: `
          <div class="tutorial-content">
            <h3>Game Controls</h3>
            <div class="controls-grid">
              <div class="control-item">
                <strong>Mouse Physics:</strong> Your mouse cursor attracts and repels electrons - use physics to guide them!
              </div>
              <div class="control-item">
                <strong>Target Mechanics:</strong> Blue electrons attract to blue targets, orange electrons repel to orange targets
              </div>
              <div class="control-item">
                <strong>Penalties:</strong> Hitting opposing targets causes penalties. Hitting filled targets twice knocks electrons out!
              </div>
              <div class="control-item">
                <strong>Time Limit:</strong> Complete each atom before time runs out
              </div>
              <div class="control-item">
                <strong>Level Up:</strong> Each element gets more complex with more electrons!
              </div>
            </div>
          </div>
        `,
        buttonText: "Continue",
      },
      {
        title: "Pro Tips for Success",
        content: `
          <div class="tutorial-content">
            <h3>Master the Physics!</h3>
            <div class="tips-list">
              <div class="tip">
                <strong>Pauli Exclusion Principle:</strong><br>
                Each orbital can hold up to 2 electrons maximum, and they must have opposite spins if both are present
              </div>
              <div class="tip">
                <strong>Hund's Rule:</strong><br>
                Electrons prefer to occupy empty orbitals first before pairing up (you'll see this in Carbon and Nitrogen!)
              </div>
              <div class="tip">
                <strong>Audio Cues:</strong><br>
                Listen for different sounds - successful captures, collisions, and level completions all have unique audio feedback
              </div>
              <div class="tip">
                <strong>Read the Facts:</strong><br>
                Each element includes real scientific facts about its properties and behavior!
              </div>
            </div>
          </div>
        `,
        buttonText: "Start Game",
      },
    ];
  }

  show() {
    this.isVisible = true;
    this.currentStep = 0;
    this.createOverlay();
    this.updateContent();
  }

  hide() {
    this.isVisible = false;
    if (this.overlay) {
      this.overlay.remove();
      this.overlay = null;
    }
    // Mark tutorial as shown
    localStorage.setItem("atomicTutorialShown", "true");
    this.hasBeenShown = true;
  }

  createOverlay() {
    this.overlay = document.createElement("div");
    this.overlay.className = "tutorial-overlay";
    this.overlay.innerHTML = `
      <div class="tutorial-modal">
        <div class="tutorial-header">
          <div class="step-indicator">
            <span class="current-step">1</span> / <span class="total-steps">${this.totalSteps}</span>
          </div>
          <button class="tutorial-close" onclick="tutorial.hide()">X</button>
        </div>
        <div class="tutorial-body">
          <h2 class="tutorial-title"></h2>
          <div class="tutorial-text"></div>
        </div>
        <div class="tutorial-footer">
          <button class="tutorial-prev" onclick="tutorial.previousStep()" style="display: none;">Previous</button>
          <button class="tutorial-next" onclick="tutorial.nextStep()">Next</button>
        </div>
      </div>
    `;

    // Add CSS styles - matching the subtle level complete menu colors
    const style = document.createElement("style");
    style.textContent = `
      /* Color theme matching level complete screen */
      :root {
        --primary-bg: #000000;
        --secondary-bg: #1a1a1a;
        --border-color: rgb(100, 150, 255);
        --title-color: rgb(255, 255, 100);
        --heading-color: rgb(100, 200, 255);
        --text-color: rgb(200, 200, 200);
        --accent-color: rgb(255, 200, 100);
        --subtle-bg: rgba(50, 50, 80, 0.3);
      }

      .tutorial-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-family: "Courier New", monospace;
      }

      .tutorial-modal {
        background: var(--primary-bg);
        border: 2px solid var(--border-color);
        border-radius: 0;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 0 20px rgba(100, 150, 255, 0.2);
        color: var(--text-color);
      }

      .tutorial-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px 20px;
        border-bottom: 1px solid var(--border-color);
        background: var(--secondary-bg);
      }

      .step-indicator {
        background: var(--subtle-bg);
        padding: 8px 16px;
        border-radius: 0;
        border: 1px solid var(--border-color);
        font-size: 12px;
        font-weight: bold;
        color: var(--heading-color);
      }

      .current-step {
        color: var(--text-color);
      }

      .tutorial-close {
        background: var(--subtle-bg);
        border: 1px solid var(--border-color);
        color: var(--heading-color);
        font-size: 14px;
        cursor: pointer;
        padding: 8px 12px;
        border-radius: 0;
        font-family: "Courier New", monospace;
        font-weight: bold;
      }

      .tutorial-close:hover {
        background: rgba(100, 150, 255, 0.2);
        color: var(--text-color);
      }

      .tutorial-body {
        padding: 25px;
        background: var(--secondary-bg);
      }

      .tutorial-title {
        color: var(--title-color);
        margin: 0 0 20px 0;
        font-size: 24px;
        font-weight: bold;
        font-family: "Courier New", monospace;
        text-align: center;
      }

      .tutorial-content h3 {
        color: var(--heading-color);
        margin: 0 0 15px 0;
        font-size: 18px;
        font-family: "Courier New", monospace;
      }

      .tutorial-content h4 {
        color: var(--accent-color);
        margin: 15px 0 10px 0;
        font-size: 14px;
        font-family: "Courier New", monospace;
      }

      .tutorial-content p {
        line-height: 1.6;
        margin: 10px 0;
        color: var(--text-color);
        font-family: "Courier New", monospace;
        font-size: 13px;
      }

      .physics-key, .physics-fact {
        background: var(--subtle-bg);
        border: 1px solid var(--border-color);
        padding: 15px;
        margin: 15px 0;
        border-radius: 0;
      }

      .spin-explanation {
        margin: 20px 0;
      }

      .spin-demo {
        display: flex;
        align-items: center;
        margin: 15px 0;
        padding: 15px;
        background: var(--subtle-bg);
        border: 1px solid var(--border-color);
        border-radius: 0;
      }

      .orb {
        width: 30px;
        height: 30px;
        border-radius: 0;
        margin-right: 20px;
        border: 2px solid var(--text-color);
      }

      .orb-inline {
        width: 16px;
        height: 16px;
        border-radius: 0;
        display: inline-block;
        margin: 0 4px;
        border: 1px solid var(--text-color);
        vertical-align: middle;
      }

      .blue-orb {
        background: #4a90e2;
      }

      .orange-orb {
        background: #ff6b35;
      }

      .spin-label strong {
        color: var(--text-color);
        font-size: 14px;
        font-family: "Courier New", monospace;
      }

      .spin-label small {
        color: rgba(200, 200, 200, 0.8);
        font-family: "Courier New", monospace;
      }

      .controls-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        margin: 20px 0;
      }

      .control-item {
        background: var(--subtle-bg);
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 0;
      }

      .control-item strong {
        color: var(--heading-color);
        font-family: "Courier New", monospace;
      }

      .keyboard-controls {
        background: var(--subtle-bg);
        padding: 15px;
        border: 1px solid var(--border-color);
        border-radius: 0;
        margin-top: 20px;
      }

      .keyboard-controls h4 {
        margin-top: 0;
      }

      .keyboard-controls p {
        margin: 10px 0 0 0;
        font-family: "Courier New", monospace;
      }

      .tips-list {
        display: grid;
        gap: 10px;
        margin: 20px 0;
      }

      .tip {
        background: var(--subtle-bg);
        padding: 15px;
        border: 1px solid var(--border-color);
        border-radius: 0;
      }

      .tip strong {
        color: var(--heading-color);
        display: block;
        margin-bottom: 8px;
        font-family: "Courier New", monospace;
      }

      .tutorial-footer {
        display: flex;
        justify-content: flex-end;
        padding: 15px 20px;
        border-top: 1px solid var(--border-color);
        background: var(--secondary-bg);
      }

      .tutorial-prev {
        margin-right: auto;
      }

      .tutorial-prev, .tutorial-next {
        background: var(--subtle-bg);
        color: var(--heading-color);
        border: 1px solid var(--border-color);
        padding: 12px 24px;
        border-radius: 0;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        font-family: "Courier New", monospace;
      }

      .tutorial-prev:hover, .tutorial-next:hover {
        background: rgba(100, 150, 255, 0.2);
        color: var(--text-color);
      }

      .tutorial-prev {
        background: var(--primary-bg);
        color: var(--accent-color);
      }

      .tutorial-prev:hover {
        background: rgba(255, 200, 100, 0.1);
      }

      @media (max-width: 600px) {
        .tutorial-modal {
          margin: 20px;
          max-height: 90vh;
        }
        
        .tutorial-body {
          padding: 15px;
        }
        
        .tutorial-header, .tutorial-footer {
          padding: 10px 15px;
        }
      }
    `;

    document.head.appendChild(style);
    document.body.appendChild(this.overlay);

    // Add click handler to close button
    this.overlay
      .querySelector(".tutorial-close")
      .addEventListener("click", (e) => {
        e.stopPropagation();
        this.hide();
      });

    // Prevent closing when clicking on modal content
    this.overlay
      .querySelector(".tutorial-modal")
      .addEventListener("click", (e) => {
        e.stopPropagation();
      });
  }

  updateContent() {
    if (!this.overlay) return;

    const step = this.steps[this.currentStep];

    this.overlay.querySelector(".current-step").textContent =
      this.currentStep + 1;
    this.overlay.querySelector(".tutorial-title").textContent = step.title;
    this.overlay.querySelector(".tutorial-text").innerHTML = step.content;

    const prevBtn = this.overlay.querySelector(".tutorial-prev");
    const nextBtn = this.overlay.querySelector(".tutorial-next");

    prevBtn.style.display = this.currentStep > 0 ? "block" : "none";
    nextBtn.textContent = step.buttonText;
  }

  nextStep() {
    if (this.currentStep < this.totalSteps - 1) {
      this.currentStep++;
      this.updateContent();
    } else {
      this.hide();
      // Start the game
      if (this.game && this.game.start) {
        this.game.start();
      }
    }
  }

  previousStep() {
    if (this.currentStep > 0) {
      this.currentStep--;
      this.updateContent();
    }
  }

  // Check if tutorial should be shown automatically
  shouldShow() {
    return !this.hasBeenShown;
  }

  // Reset tutorial (for testing or if user wants to see it again)
  reset() {
    localStorage.removeItem("atomicTutorialShown");
    this.hasBeenShown = false;
  }
}


// Simple input handling for mouse position
class InputSystem {
  constructor(canvas) {
    this.mouse = { x: canvas.width / 2, y: canvas.height / 2 };

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      this.mouse.x = e.clientX - rect.left;
      this.mouse.y = e.clientY - rect.top;
    });
  }
}


// Simple atomic orbital system with progressive levels
class OrbitalSystem {
  constructor(canvas, audioSystem = null) {
    this.canvas = canvas;
    this.currentLevel = 0;
    this.score = 0;
    this.TAU = Math.PI * 2; // 2π constant for efficiency
    this.time = 0;
    this.levelTime = 45; // 45 seconds per level
    this.audio = audioSystem; // Reference to audio system
    this.timeWarningPlayed = false; // Track if time warning sound has been played

    // Orbital factory for consistent properties and smaller code
    const G3 = Math.PI / 3,
      G4 = Math.PI / 4,
      G5 = Math.PI / 5,
      G6 = Math.PI / 6,
      Gsharp4 = Math.PI / 3.5, // G# orbital gap size
      A4 = Math.PI / 4.5; // A orbital gap size

    // Center coordinates for atomic structure
    const CX = this.canvas.width / 2;
    const CY = this.canvas.height / 2;

    // Shell factory: (shell, position_angle, type, gap_size, rotation_speed)
    const shell = (radius, angle, type, gap = G4, speed = 0.02) => ({
      x: CX + Math.cos(angle) * radius,
      y: CY + Math.sin(angle) * radius,
      type,
      speed,
      gap,
      radius: 20,
      rotate: true,
      shell: radius, // Track which shell this belongs to
    });

    // Proper Bohr model shell radii and configurations
    // K shell (n=1): max 2 electrons, radius ~80px
    // L shell (n=2): max 8 electrons, radius ~140px
    // M shell (n=3): max 18 electrons, radius ~200px
    const K_SHELL = 80; // First shell (1s orbital)
    const L_SHELL = 140; // Second shell (2s, 2p orbitals)
    const M_SHELL = 200; // Third shell (3s, 3p, 3d orbitals)

    // Real atomic structures based on proper Bohr model
    this.levels = [
      {
        name: "Hydrogen (H)",
        element: "H",
        atomicNumber: 1,
        description: "1 electron in K shell (1s orbital)",
        funFact:
          "Hydrogen is the most abundant element in the universe! Each electron has an intrinsic quantum property called 'spin' - either spin-up (↑) or spin-down (↓).",
        shells: [K_SHELL], // K shell only
        orbitals: [
          shell(K_SHELL, 0, "blue", G3, 0.025), // 1s¹ (spin-down)
        ],
      },
      {
        name: "Helium (He)",
        element: "He",
        atomicNumber: 2,
        description: "2 electrons fill the K shell (1s orbital)",
        funFact:
          "Helium demonstrates the Pauli Exclusion Principle - each orbital can hold exactly 2 electrons, but they must have opposite spins (↑↓)!",
        shells: [K_SHELL], // K shell only
        orbitals: [
          shell(K_SHELL, 0, "blue", G4, 0.022), // 1s¹ (spin-down)
          shell(K_SHELL, Math.PI, "orange", G4, 0.022), // 1s² (spin-up)
        ],
      },
      {
        name: "Lithium (Li)",
        element: "Li",
        atomicNumber: 3,
        description: "K shell filled (2e⁻), 1 electron in L shell",
        funFact:
          "Lithium's 3rd electron goes into the L shell because the K shell is full with its spin-paired electrons (↑↓)!",
        shells: [K_SHELL, L_SHELL], // K and L shells
        orbitals: [
          shell(K_SHELL, 0, "blue", G4, 0.022), // 1s¹ (spin-down)
          shell(K_SHELL, Math.PI, "orange", G4, 0.022), // 1s² (spin-up)
          shell(L_SHELL, 0, "orange", Gsharp4, 0.022), // 2s¹ (spin-up)
        ],
      },
      {
        name: "Carbon (C)",
        element: "C",
        atomicNumber: 6,
        description: "K shell: 2e⁻, L shell: 4e⁻ (2s² 2p²)",
        funFact:
          "Carbon's 2p electrons follow Hund's Rule - they occupy separate orbitals with parallel spins (↑ ↑) before pairing up!",
        shells: [K_SHELL, L_SHELL], // K and L shells
        orbitals: [
          shell(K_SHELL, 0, "blue", G4, 0.022), // 1s¹ (spin-down)
          shell(K_SHELL, Math.PI, "orange", G4, 0.022), // 1s² (spin-up)
          shell(L_SHELL, 0, "blue", Gsharp4, 0.02), // 2s¹ (spin-down)
          shell(L_SHELL, Math.PI, "orange", Gsharp4, 0.02), // 2s² (spin-up)
          shell(L_SHELL, Math.PI / 2, "orange", A4, 0.02), // 2p¹ (spin-up)
          shell(L_SHELL, (3 * Math.PI) / 2, "orange", A4, 0.02), // 2p² (spin-up)
        ],
      },
      {
        name: "Nitrogen (N)",
        element: "N",
        atomicNumber: 7,
        description: "K shell: 2e⁻, L shell: 5e⁻ (2s² 2p³)",
        funFact:
          "Nitrogen has maximum unpaired electrons in its 2p orbitals (↑ ↑ ↑), making it very stable and unreactive!",
        shells: [K_SHELL, L_SHELL], // K and L shells
        orbitals: [
          shell(K_SHELL, 0, "blue", G4, 0.022), // 1s¹ (spin-down)
          shell(K_SHELL, Math.PI, "orange", G4, 0.022), // 1s² (spin-up)
          shell(L_SHELL, 0, "blue", Gsharp4, 0.022), // 2s¹ (spin-down)
          shell(L_SHELL, Math.PI, "orange", Gsharp4, 0.022), // 2s² (spin-up)
          shell(L_SHELL, Math.PI / 2, "orange", A4, 0.022), // 2p¹ (spin-up)
          shell(L_SHELL, (3 * Math.PI) / 2, "orange", A4, 0.022), // 2p² (spin-up)
          shell(L_SHELL, Math.PI / 4, "orange", A4, 0.022), // 2p³ (spin-up)
        ],
      },
    ];

    this.showingTip = false;
    this.tipStartTime = 0;
    this.resetLevel();
  }

  resetLevel() {
    this.orbitals = this.levels[this.currentLevel].orbitals.map((o) => ({
      x: o.x,
      y: o.y,
      radius: o.radius,
      type: o.type,
      occupied: false,
      rotate: o.rotate,
      speed: o.speed,
      gap: o.gap,
      angle: 0,
      electronAngle: 0, // Angle for electron orbiting around the orbital edge
      stunned: false,
      stunnedTime: 0,
      hitCount: 0,
      shaking: false,
      shakeTime: 0,
      shakeOffsetX: 0,
      shakeOffsetY: 0,
    }));
    this.time = 0;
    this.timeWarningPlayed = false; // Reset time warning for new level
  }

  checkCompletion() {
    return this.orbitals.every((o) => o.occupied);
  }

  update() {
    const M = Math; // Shorter reference
    this.time += 1 / 60; // Assuming 60fps

    // Auto-hide educational tip after 4 seconds
    if (this.showingTip && this.time - this.tipStartTime > 4) {
      this.showingTip = false;
    }

    // Update rotating orbitals
    for (let orbital of this.orbitals) {
      if (orbital.rotate) {
        orbital.angle += orbital.speed;
      }

      // Update electron orbiting motion for occupied orbitals
      if (orbital.occupied) {
        orbital.electronAngle += orbital.speed * 3; // Electrons orbit faster than gap rotation
      }

      // Update stunned orbitals
      if (orbital.stunned) {
        orbital.stunnedTime -= 1 / 60;
        if (orbital.stunnedTime <= 0) {
          orbital.stunned = false;
        }
      }

      // Update shaking orbitals
      if (orbital.shaking) {
        orbital.shakeTime -= 1 / 60;
        if (orbital.shakeTime <= 0) {
          orbital.shaking = false;
          orbital.shakeOffsetX = 0;
          orbital.shakeOffsetY = 0;
        } else {
          // Generate random shake offset
          let intensity = orbital.shakeTime * 8; // Fade out over time
          orbital.shakeOffsetX = (M.random() - 0.5) * intensity;
          orbital.shakeOffsetY = (M.random() - 0.5) * intensity;
        }
      }
    }
  }

  // Check if electron can enter orbital gap
  canEnterOrbital(orbital, electronX, electronY) {
    if (orbital.stunned) return false; // Stunned orbitals can't accept electrons

    let dx = electronX - orbital.x,
      dy = electronY - orbital.y;
    let electronAngle = Math.atan2(dy, dx);
    let relativeAngle = (electronAngle - orbital.angle + this.TAU) % this.TAU;

    return (
      relativeAngle < orbital.gap || relativeAngle > this.TAU - orbital.gap
    );
  }

  // Stun an orbital when wrong-color electron hits it
  stunOrbital(orbital) {
    orbital.stunned = true;
    orbital.stunnedTime = 3; // 3 seconds stun duration

    // Play stun sound
    if (this.audio) {
      this.audio.playOrbitalStun();
    }
  }

  // Handle hits on occupied orbitals
  hitOccupiedOrbital(orbital) {
    orbital.hitCount++;
    orbital.shaking = true;
    orbital.shakeTime = 0.5; // Shake for 0.5 seconds

    if (orbital.hitCount >= 2) {
      // Knock out the electron
      orbital.occupied = false;
      orbital.hitCount = 0;
      orbital.shaking = false;
      orbital.shakeOffsetX = 0;
      orbital.shakeOffsetY = 0;
      return true; // Electron was knocked out
    }
    return false; // Electron still in orbital
  }

  nextLevel() {
    if (this.checkCompletion()) {
      this.score += (this.currentLevel + 1) * 100;

      // Show educational tip
      this.showingTip = true;
      this.tipStartTime = this.time;

      this.currentLevel++;
      if (this.currentLevel >= this.levels.length) {
        this.currentLevel = 0; // Loop back
      }
      this.resetLevel();
      return true;
    }
    return false;
  }

  // Close educational tip
  closeTip() {
    this.showingTip = false;
  }

  draw(ctx) {
    // Color helpers for smaller code
    const colors = {
      blue: ["rgba(100,150,255,", "rgb(100,150,255)", "rgb(80,120,200)"],
      orange: ["rgba(255,150,100,", "rgb(255,150,100)", "rgb(200,120,80)"],
      grey: "rgb(128,128,128)",
    };

    const level = this.levels[this.currentLevel];
    const CX = this.canvas.width / 2;
    const CY = this.canvas.height / 2;

    // Draw nucleus at center
    ctx.save();
    ctx.shadowColor = "rgba(255, 255, 100, 0.8)";
    ctx.shadowBlur = 15;

    let nucleusGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, 15);
    nucleusGrad.addColorStop(0, "rgb(255, 255, 150)");
    nucleusGrad.addColorStop(0.7, "rgb(255, 200, 100)");
    nucleusGrad.addColorStop(1, "rgb(200, 150, 50)");

    ctx.fillStyle = nucleusGrad;
    ctx.beginPath();
    ctx.arc(CX, CY, 12, 0, this.TAU);
    ctx.fill();

    // Nucleus label
    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgb(50, 50, 50)";
    ctx.font = "10px 'Courier New', monospace";
    ctx.textAlign = "center";
    ctx.fillText(level.element, CX, CY + 3);
    ctx.textAlign = "left";
    ctx.restore();

    // Draw electron shells as concentric circles around nucleus
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;

    // Draw visible shell rings for the current element
    const levelData = this.levels[this.currentLevel];
    if (levelData.shells) {
      for (let shellRadius of levelData.shells) {
        ctx.save();
        ctx.strokeStyle = "rgba(100, 150, 255, 0.25)";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(centerX, centerY, shellRadius, 0, this.TAU);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
    }

    // Draw orbital targets on each shell
    for (let orbital of this.orbitals) {
      ctx.save();

      let c = colors[orbital.type] || colors.grey;
      let occ = orbital.occupied;
      let stunned = orbital.stunned;

      // Draw orbital boundary (always visible as outline)
      const orbitalRadius = 20; // Larger, more visible orbital size

      // Orbital outline ring - colored based on orbital type
      if (occ) {
        // Occupied orbitals keep the faint colored outline
        ctx.strokeStyle = stunned ? "rgba(120,120,120,0.4)" : c[0] + "0.4)";
      } else {
        // Empty orbitals have a more visible colored outline to show which electron type is needed
        ctx.strokeStyle = stunned ? "rgba(120,120,120,0.6)" : c[0] + "0.7)";
      }
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.arc(orbital.x, orbital.y, orbitalRadius, 0, this.TAU);
      ctx.stroke();

      // Subtle orbital field background
      let fieldGrad = ctx.createRadialGradient(
        orbital.x,
        orbital.y,
        0,
        orbital.x,
        orbital.y,
        orbitalRadius
      );
      fieldGrad.addColorStop(
        0,
        stunned ? "rgba(100,100,100,0.05)" : c[0] + "0.05)"
      );
      fieldGrad.addColorStop(1, "rgba(0,0,0,0)");

      ctx.fillStyle = fieldGrad;
      ctx.beginPath();
      ctx.arc(orbital.x, orbital.y, orbitalRadius, 0, this.TAU);
      ctx.fill();

      if (occ) {
        // Occupied orbital - electron orbiting around the edge
        const electronOrbitRadius = orbitalRadius - 2; // Slightly inside the orbital boundary

        // Calculate electron position
        let electronX =
          orbital.x + Math.cos(orbital.electronAngle) * electronOrbitRadius;
        let electronY =
          orbital.y + Math.sin(orbital.electronAngle) * electronOrbitRadius;

        // Apply shake offset to the entire orbital system
        electronX += orbital.shakeOffsetX;
        electronY += orbital.shakeOffsetY;

        // Draw orbiting electron
        ctx.shadowColor = c[0] + "0.8)";
        ctx.shadowBlur = 8;

        let grad = ctx.createRadialGradient(
          electronX,
          electronY,
          0,
          electronX,
          electronY,
          6
        );
        grad.addColorStop(0, "white");
        grad.addColorStop(0.4, c[1]);
        grad.addColorStop(1, c[2]);

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(electronX, electronY, 6, 0, this.TAU);
        ctx.fill();

        // Optional: Draw faint orbital trail
        ctx.shadowBlur = 0;
        ctx.strokeStyle = c[0] + "0.2)";
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        ctx.beginPath();
        ctx.arc(orbital.x, orbital.y, electronOrbitRadius, 0, this.TAU);
        ctx.stroke();
        ctx.setLineDash([]);
      } else {
        // Available orbital - show rotating entry gap
        ctx.translate(orbital.x, orbital.y);
        ctx.rotate(orbital.angle);

        // Entry gap in the orbital ring
        ctx.strokeStyle = stunned
          ? "rgba(200,200,200,0.8)"
          : c[1].replace("rgb", "rgba").replace(")", ",0.9)");
        ctx.lineWidth = 3;
        ctx.beginPath();
        let g = orbital.gap / 2;
        ctx.arc(0, 0, orbitalRadius, g, this.TAU - g);
        ctx.stroke();

        // Entry gap indicators (pointing inward)
        ctx.strokeStyle = stunned
          ? "rgba(160,160,160,0.9)"
          : c[1].replace("rgb", "rgba").replace(")", ",0.8)");
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(orbitalRadius * Math.cos(g), orbitalRadius * Math.sin(g));
        ctx.lineTo(
          (orbitalRadius - 6) * Math.cos(g),
          (orbitalRadius - 6) * Math.sin(g)
        );
        ctx.moveTo(orbitalRadius * Math.cos(-g), orbitalRadius * Math.sin(-g));
        ctx.lineTo(
          (orbitalRadius - 6) * Math.cos(-g),
          (orbitalRadius - 6) * Math.sin(-g)
        );
        ctx.stroke();

        // Center indicator dot
        let pulse = 0.3 + 0.3 * Math.sin(this.time * 2.5);
        ctx.fillStyle = stunned
          ? `rgba(140,140,140,${pulse})`
          : c[0] + `${pulse})`;
        ctx.beginPath();
        ctx.arc(0, 0, 3, 0, this.TAU);
        ctx.fill();
      }

      ctx.restore();
    }

    // UI Constants
    const F16 = "16px Arial";
    const F18 = "18px 'Courier New', monospace";
    const F12 = "12px Arial";
    const WHITE = "white";
    const CYAN = "rgb(0, 255, 255)";
    const YELLOW = "rgb(255, 255, 100)";

    const currentLevel = this.levels[this.currentLevel];

    // Element name and atomic number
    ctx.fillStyle = WHITE;
    ctx.font = F18;
    ctx.fillText(`${currentLevel.name}`, 20, 30);

    // Atomic number in a styled box
    ctx.save();
    ctx.fillStyle = "rgba(100, 150, 255, 0.2)";
    ctx.fillRect(200, 10, 40, 30);
    ctx.strokeStyle = "rgb(100, 150, 255)";
    ctx.lineWidth = 1;
    ctx.strokeRect(200, 10, 40, 30);

    ctx.fillStyle = CYAN;
    ctx.font = "14px 'Courier New', monospace";
    ctx.textAlign = "center";
    ctx.fillText(currentLevel.atomicNumber.toString(), 220, 30);
    ctx.textAlign = "left";
    ctx.restore();

    // Score text with muted styling like element name
    ctx.fillStyle = WHITE;
    ctx.font = F18;
    ctx.fillText(`SCORE: ${this.score}`, 20, 55);

    ctx.fillStyle = WHITE;
    ctx.font = F18;
    ctx.fillText(
      `Electrons: ${this.orbitals.filter((o) => o.occupied).length}/${
        this.orbitals.length
      }`,
      20,
      75
    );

    // Timer display
    let timeLeft = Math.max(0, this.levelTime - this.time);
    ctx.fillStyle = timeLeft < 10 ? "rgb(255,100,100)" : "white";
    ctx.fillText(`Time: ${timeLeft.toFixed(1)}s`, 20, 95);

    // Play time warning sound when 10 seconds left (only once per level)
    if (
      timeLeft <= 10 &&
      timeLeft > 0 &&
      !this.timeWarningPlayed &&
      this.audio
    ) {
      this.audio.playTimeWarning();
      this.timeWarningPlayed = true;
    }

    if (this.checkCompletion()) {
      ctx.save();

      // Center the completion text
      ctx.textAlign = "center";
      ctx.font = "32px 'Courier New', monospace";

      // Multiple glow layers for enhanced effect
      ctx.shadowColor = "rgb(255, 255, 0)";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "rgb(255, 255, 0)";
      ctx.fillText("LEVEL COMPLETE", this.canvas.width / 2, 150);

      // Secondary glow
      ctx.shadowColor = "rgb(255, 200, 0)";
      ctx.shadowBlur = 30;
      ctx.fillStyle = "rgb(255, 255, 200)";
      ctx.fillText("LEVEL COMPLETE", this.canvas.width / 2, 150);

      // Smaller instruction text
      ctx.font = "18px 'Courier New', monospace";
      ctx.shadowColor = "rgb(0, 255, 255)";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "rgb(0, 255, 255)";
      ctx.fillText(">> CLICK FOR NEXT LEVEL <<", this.canvas.width / 2, 180);

      ctx.restore();
    } else if (timeLeft <= 0) {
      ctx.save();
      ctx.textAlign = "center";
      ctx.font = "24px 'Courier New', monospace";
      ctx.shadowColor = "rgb(255, 100, 100)";
      ctx.shadowBlur = 15;
      ctx.fillStyle = "rgb(255, 100, 100)";
      ctx.fillText("TIME'S UP! CLICK TO RETRY", this.canvas.width / 2, 150);
      ctx.restore();
    }

    // Educational tip overlay
    if (this.showingTip) {
      const prevLevel =
        this.currentLevel === 0
          ? this.levels.length - 1
          : this.currentLevel - 1;
      const completedLevel = this.levels[prevLevel];

      // Semi-transparent overlay
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

      // Educational tip box
      const boxWidth = 500;
      const boxHeight = 200;
      const boxX = (this.canvas.width - boxWidth) / 2;
      const boxY = (this.canvas.height - boxHeight) / 2;

      // Tip box background
      ctx.fillStyle = "rgba(20, 30, 50, 0.95)";
      ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

      // Tip box border
      ctx.strokeStyle = "rgb(100, 150, 255)";
      ctx.lineWidth = 2;
      ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

      ctx.textAlign = "center";

      // Congratulations header
      ctx.fillStyle = "rgb(255, 255, 100)";
      ctx.font = "24px 'Courier New', monospace";
      ctx.fillText("ELEMENT BUILT!", this.canvas.width / 2, boxY + 40);

      // Element details
      ctx.fillStyle = "rgb(100, 200, 255)";
      ctx.font = "20px 'Courier New', monospace";
      ctx.fillText(
        `${completedLevel.name} (${completedLevel.element})`,
        this.canvas.width / 2,
        boxY + 70
      );

      ctx.fillStyle = "rgb(200, 200, 200)";
      ctx.font = "16px Arial";
      ctx.fillText(
        `Atomic Number: ${completedLevel.atomicNumber}`,
        this.canvas.width / 2,
        boxY + 95
      );

      // Fun fact
      ctx.fillStyle = "rgb(255, 200, 100)";
      ctx.font = "14px Arial";

      // Word wrap the fun fact
      const words = completedLevel.funFact.split(" ");
      let line = "";
      let lineY = boxY + 125;

      for (let word of words) {
        const testLine = line + word + " ";
        const metrics = ctx.measureText(testLine);

        if (metrics.width > boxWidth - 40 && line !== "") {
          ctx.fillText(line, this.canvas.width / 2, lineY);
          line = word + " ";
          lineY += 20;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, this.canvas.width / 2, lineY);

      // Auto-close instruction
      ctx.fillStyle = "rgba(150, 150, 150, 0.8)";
      ctx.font = "12px Arial";
      ctx.fillText(
        "(Auto-closes in " +
          Math.ceil(4 - (this.time - this.tipStartTime)) +
          "s | Click anywhere or press ESC to close)",
        this.canvas.width / 2,
        boxY + boxHeight - 15
      );

      ctx.restore();
    }
  }
}


// Futuristic electronic audio system using Web Audio API
class AudioSystem {
  constructor() {
    this.audioContext = null;
    this.masterGain = null;
    this.backgroundMusic = null;
    this.isInitialized = false;
    this.isMuted = false;

    // Audio settings
    this.volume = 0.4;
    this.musicVolume = 0.7; // Increased significantly to make music more audible
    this.sfxVolume = 0.4;
  }

  // Initialize audio context (must be called after user interaction)
  async init() {
    if (this.isInitialized) return;

    try {
      this.audioContext = new (window.AudioContext ||
        window.webkitAudioContext)();
      this.masterGain = this.audioContext.createGain();
      this.masterGain.connect(this.audioContext.destination);
      this.masterGain.gain.value = this.volume;

      this.isInitialized = true;
      console.log("Audio system initialized");

      // Start ambient background music
      this.startBackgroundMusic();
    } catch (error) {
      console.warn("Audio initialization failed:", error);
    }
  }

  // Generate ultra-chill ambient background music
  startBackgroundMusic() {
    if (!this.isInitialized || this.backgroundMusic) return;

    const musicGain = this.audioContext.createGain();
    musicGain.connect(this.masterGain);
    musicGain.gain.value = this.musicVolume;

    // Simple, peaceful chord progression - all major/consonant chords
    // Using C - F - Am - G progression (very stable and calming)
    const chordProgression = [
      [130.81, 164.81, 196.0], // C major (C-E-G) - peaceful home
      [174.61, 220.0, 261.63], // F major (F-A-C) - warm and stable
      [220.0, 261.63, 329.63], // A minor (A-C-E) - gentle and soft
      [196.0, 246.94, 293.66], // G major (G-B-D) - uplifting resolution
    ];

    const oscillators = [];
    let currentChord = 0;
    let nextChordTime = this.audioContext.currentTime;

    // Function to play very soft, warm chords
    const playChord = (frequencies, startTime, duration) => {
      frequencies.forEach((freq, index) => {
        const osc = this.audioContext.createOscillator();
        const oscGain = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();

        // Pure sine waves for maximum smoothness
        osc.type = "sine";
        osc.frequency.value = freq * 0.5; // Low octave for warmth

        // Very gentle low-pass filter to remove any harsh frequencies
        filter.type = "lowpass";
        filter.frequency.value = 800; // Increased from 400 to let more harmonics through
        filter.Q.value = 0.1; // Very gentle filtering

        // Extremely gentle fade in/out - no sudden changes
        oscGain.gain.setValueAtTime(0, startTime);
        oscGain.gain.linearRampToValueAtTime(0.15, startTime + 2); // Increased from 0.08 to be more audible
        oscGain.gain.setValueAtTime(0.15, startTime + duration - 2);
        oscGain.gain.linearRampToValueAtTime(0, startTime + duration);

        osc.connect(filter);
        filter.connect(oscGain);
        oscGain.connect(musicGain);

        osc.start(startTime);
        osc.stop(startTime + duration);
      });
    };

    // Schedule chord progression with longer, more relaxed timing
    const scheduleNextChord = () => {
      const chordDuration = 8; // 8 seconds per chord for maximum calm
      playChord(chordProgression[currentChord], nextChordTime, chordDuration);

      console.log(`Playing chord ${currentChord + 1} at time ${nextChordTime}`);

      currentChord = (currentChord + 1) % chordProgression.length;
      nextChordTime += chordDuration;

      // Schedule next chord
      setTimeout(() => scheduleNextChord(), (chordDuration - 1.5) * 1000);
    }; // Remove the high ambient layer that might be grating
    // Just keep one very subtle bass pad
    const bassPad = this.audioContext.createOscillator();
    const bassPadGain = this.audioContext.createGain();
    const bassPadFilter = this.audioContext.createBiquadFilter();

    bassPad.type = "triangle";
    bassPad.frequency.value = 65.41; // Low C

    bassPadFilter.type = "lowpass";
    bassPadFilter.frequency.value = 200; // Very low
    bassPadFilter.Q.value = 0.1;

    bassPadGain.gain.value = 0.01; // Increased from 0.002 to be more audible

    bassPad.connect(bassPadFilter);
    bassPadFilter.connect(bassPadGain);
    bassPadGain.connect(musicGain);

    bassPad.start();
    oscillators.push(bassPad);

    // Very subtle, slow LFO for gentle movement
    const lfo = this.audioContext.createOscillator();
    const lfoGain = this.audioContext.createGain();
    lfo.type = "sine";
    lfo.frequency.value = 0.03; // Extremely slow
    lfoGain.gain.value = 15; // Very gentle modulation

    lfo.connect(lfoGain);
    lfoGain.connect(bassPadFilter.frequency);
    lfo.start();

    // Start the chord progression
    scheduleNextChord();

    this.backgroundMusic = { oscillators, lfo, musicGain };
    console.log("Ultra-chill ambient background music started");
  }

  // Electron capture sound - soft, crystalline
  playElectronCapture() {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);
    gain.gain.value = this.sfxVolume * 0.5;

    // Soft crystal-like chime using multiple harmonics
    const frequencies = [523.25, 659.25, 783.99]; // C major triad high octave

    frequencies.forEach((freq, index) => {
      const osc = this.audioContext.createOscillator();
      const oscGain = this.audioContext.createGain();
      const filter = this.audioContext.createBiquadFilter();

      osc.type = "triangle";
      osc.frequency.value = freq;

      filter.type = "lowpass";
      filter.frequency.value = 3000;
      filter.Q.value = 2;

      const startTime = this.audioContext.currentTime + index * 0.05;

      oscGain.gain.setValueAtTime(0, startTime);
      oscGain.gain.linearRampToValueAtTime(0.2, startTime + 0.02);
      oscGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);

      osc.connect(filter);
      filter.connect(oscGain);
      oscGain.connect(gain);

      osc.start(startTime);
      osc.stop(startTime + 0.4);
    });
  }

  // Wrong electron type collision - soft negative feedback
  playWrongElectron() {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);

    // Soft dissonant chord that resolves downward
    const osc1 = this.audioContext.createOscillator();
    const osc2 = this.audioContext.createOscillator();

    osc1.type = "triangle";
    osc1.frequency.setValueAtTime(349.23, this.audioContext.currentTime); // F
    osc1.frequency.exponentialRampToValueAtTime(
      261.63,
      this.audioContext.currentTime + 0.3
    ); // to C

    osc2.type = "triangle";
    osc2.frequency.setValueAtTime(369.99, this.audioContext.currentTime); // F#
    osc2.frequency.exponentialRampToValueAtTime(
      246.94,
      this.audioContext.currentTime + 0.3
    ); // to B

    const osc1Gain = this.audioContext.createGain();
    const osc2Gain = this.audioContext.createGain();

    osc1Gain.gain.value = 0.15;
    osc2Gain.gain.value = 0.15;

    osc1.connect(osc1Gain);
    osc2.connect(osc2Gain);
    osc1Gain.connect(gain);
    osc2Gain.connect(gain);

    // Soft envelope
    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
    gain.gain.linearRampToValueAtTime(
      this.sfxVolume * 0.3,
      this.audioContext.currentTime + 0.05
    );
    gain.gain.exponentialRampToValueAtTime(
      0.001,
      this.audioContext.currentTime + 0.35
    );

    osc1.start();
    osc2.start();
    osc1.stop(this.audioContext.currentTime + 0.35);
    osc2.stop(this.audioContext.currentTime + 0.35);
  }

  // Level completion - celebratory but calm
  playLevelComplete() {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);
    gain.gain.value = this.sfxVolume * 0.8;

    // Ascending arpeggio
    const frequencies = [440, 554.37, 659.25, 880]; // A major chord progression

    frequencies.forEach((freq, index) => {
      const osc = this.audioContext.createOscillator();
      osc.type = "sine";
      osc.frequency.value = freq;

      const noteGain = this.audioContext.createGain();
      noteGain.connect(gain);

      const startTime = this.audioContext.currentTime + index * 0.1;
      const duration = 0.4;

      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.3, startTime + 0.05);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

      osc.connect(noteGain);
      osc.start(startTime);
      osc.stop(startTime + duration);
    });
  }

  // Electron knocked out - gentle thud
  playElectronKnockedOut() {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);

    // Low frequency thud with some harmonics
    const osc1 = this.audioContext.createOscillator();
    const osc2 = this.audioContext.createOscillator();

    osc1.type = "sine";
    osc1.frequency.value = 120;

    osc2.type = "triangle";
    osc2.frequency.value = 60;

    const osc1Gain = this.audioContext.createGain();
    const osc2Gain = this.audioContext.createGain();

    osc1Gain.gain.value = 0.4;
    osc2Gain.gain.value = 0.6;

    osc1.connect(osc1Gain);
    osc2.connect(osc2Gain);
    osc1Gain.connect(gain);
    osc2Gain.connect(gain);

    // Quick thud envelope
    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
    gain.gain.linearRampToValueAtTime(
      this.sfxVolume * 0.5,
      this.audioContext.currentTime + 0.01
    );
    gain.gain.exponentialRampToValueAtTime(
      0.001,
      this.audioContext.currentTime + 0.15
    );

    osc1.start();
    osc2.start();
    osc1.stop(this.audioContext.currentTime + 0.15);
    osc2.stop(this.audioContext.currentTime + 0.15);
  }

  // Orbital stun effect - electronic glitch
  playOrbitalStun() {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);
    gain.gain.value = this.sfxVolume * 0.3;

    // Create a brief electronic glitch sound
    const noise = this.audioContext.createBufferSource();
    const buffer = this.audioContext.createBuffer(1, 4410, 44100); // 0.1 seconds
    const data = buffer.getChannelData(0);

    // Generate filtered noise
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.exp(-i / 1000);
    }

    noise.buffer = buffer;

    const filter = this.audioContext.createBiquadFilter();
    filter.type = "bandpass";
    filter.frequency.value = 800;
    filter.Q.value = 5;

    noise.connect(filter);
    filter.connect(gain);

    noise.start();
  }

  // Hover/UI feedback - subtle beep
  playUIHover() {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);

    const osc = this.audioContext.createOscillator();
    osc.type = "sine";
    osc.frequency.value = 800;

    // Very brief and quiet
    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
    gain.gain.linearRampToValueAtTime(
      this.sfxVolume * 0.2,
      this.audioContext.currentTime + 0.01
    );
    gain.gain.exponentialRampToValueAtTime(
      0.001,
      this.audioContext.currentTime + 0.05
    );

    osc.connect(gain);
    osc.start();
    osc.stop(this.audioContext.currentTime + 0.05);
  }

  // Orbital collision - when hitting occupied orbital without knocking out
  playOrbitalCollision() {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);

    // Similar to wrong electron but shorter and less dissonant
    const osc = this.audioContext.createOscillator();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(330, this.audioContext.currentTime);
    osc.frequency.exponentialRampToValueAtTime(
      280,
      this.audioContext.currentTime + 0.1
    );

    // Quick bounce sound
    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
    gain.gain.linearRampToValueAtTime(
      this.sfxVolume * 0.3,
      this.audioContext.currentTime + 0.01
    );
    gain.gain.exponentialRampToValueAtTime(
      0.001,
      this.audioContext.currentTime + 0.12
    );

    osc.connect(gain);
    osc.start();
    osc.stop(this.audioContext.currentTime + 0.12);
  }

  // Game over sound - when timer runs out
  playGameOver() {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);
    gain.gain.value = this.sfxVolume * 0.6;

    // Descending minor chord - melancholy but not harsh
    const frequencies = [523.25, 415.3, 349.23, 261.63]; // C - Ab - F - C (minor)

    frequencies.forEach((freq, index) => {
      const osc = this.audioContext.createOscillator();
      osc.type = "triangle";
      osc.frequency.value = freq;

      const noteGain = this.audioContext.createGain();
      noteGain.connect(gain);

      const startTime = this.audioContext.currentTime + index * 0.15;
      const duration = 0.6;

      noteGain.gain.setValueAtTime(0, startTime);
      noteGain.gain.linearRampToValueAtTime(0.25, startTime + 0.1);
      noteGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

      osc.connect(noteGain);
      osc.start(startTime);
      osc.stop(startTime + duration);
    });
  }

  // Subtle orbital gliding sound for when electrons are moving
  playOrbitalGlide(velocity = 1.0) {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);
    gain.gain.value = this.sfxVolume * 0.1 * Math.min(velocity, 1.0); // Very subtle, velocity-based

    // Create a soft whoosh using filtered noise
    const osc = this.audioContext.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.value = 80 + velocity * 40; // Low frequency that varies with speed

    const filter = this.audioContext.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 200 + velocity * 100;
    filter.Q.value = 2;

    // Very brief, subtle sound
    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
    gain.gain.linearRampToValueAtTime(
      gain.gain.value,
      this.audioContext.currentTime + 0.02
    );
    gain.gain.exponentialRampToValueAtTime(
      0.001,
      this.audioContext.currentTime + 0.15
    );

    osc.connect(filter);
    filter.connect(gain);

    osc.start();
    osc.stop(this.audioContext.currentTime + 0.15);
  }

  // Time running out warning sound
  playTimeWarning() {
    if (!this.isInitialized) return;

    const gain = this.audioContext.createGain();
    gain.connect(this.masterGain);
    gain.gain.value = this.sfxVolume * 0.4;

    // Urgent but not harsh warning tone
    const osc1 = this.audioContext.createOscillator();
    const osc2 = this.audioContext.createOscillator();

    osc1.type = "triangle";
    osc2.type = "triangle";
    osc1.frequency.value = 440; // A4
    osc2.frequency.value = 554; // C#5 - creates tension

    // Pulsing envelope for urgency
    gain.gain.setValueAtTime(0, this.audioContext.currentTime);
    gain.gain.linearRampToValueAtTime(
      0.3,
      this.audioContext.currentTime + 0.05
    );
    gain.gain.linearRampToValueAtTime(
      0.1,
      this.audioContext.currentTime + 0.15
    );
    gain.gain.linearRampToValueAtTime(
      0.3,
      this.audioContext.currentTime + 0.25
    );
    gain.gain.exponentialRampToValueAtTime(
      0.001,
      this.audioContext.currentTime + 0.5
    );

    osc1.connect(gain);
    osc2.connect(gain);

    osc1.start();
    osc2.start();
    osc1.stop(this.audioContext.currentTime + 0.5);
    osc2.stop(this.audioContext.currentTime + 0.5);
  }

  // Toggle mute
  toggleMute() {
    this.isMuted = !this.isMuted;
    if (this.masterGain) {
      this.masterGain.gain.value = this.isMuted ? 0 : this.volume;
    }
    return this.isMuted;
  }

  // Cleanup
  destroy() {
    if (this.backgroundMusic) {
      // Stop all oscillators (both chord and ambient layers)
      this.backgroundMusic.oscillators.forEach((osc) => {
        if (osc && osc.stop) {
          try {
            osc.stop();
          } catch (e) {
            // Oscillator may already be stopped
          }
        }
      });

      if (this.backgroundMusic.lfo) {
        try {
          this.backgroundMusic.lfo.stop();
        } catch (e) {
          // LFO may already be stopped
        }
      }

      this.backgroundMusic = null;
    }

    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }

    this.isInitialized = false;
  }
}


// Simple atomic physics game
class Game {
  constructor() {
    this.canvas = document.getElementById("gameCanvas");
    this.ctx = this.canvas.getContext("2d");

    // Systems
    this.input = new InputSystem(this.canvas);
    this.audio = new AudioSystem();
    this.orbitals = new OrbitalSystem(this.canvas, this.audio);
    this.tutorial = new Tutorial(this);

    // Electrons
    this.electrons = [];
    this.spawnElectrons();

    // Background particles for atmosphere
    this.particles = [];
    this.spawnParticles();

    // Click handler for level progression/restart and tip closing
    this.canvas.addEventListener("click", async () => {
      // Initialize audio on first user interaction
      if (!this.audio.isInitialized) {
        await this.audio.init();
      }

      // Check if educational tip is showing
      if (this.orbitals.showingTip) {
        this.orbitals.closeTip();
        this.audio.playUIHover();
        return;
      }

      let timeLeft = Math.max(0, this.orbitals.levelTime - this.orbitals.time);
      if (this.orbitals.checkCompletion()) {
        this.audio.playLevelComplete();
        this.orbitals.nextLevel();
        this.spawnElectrons();
      } else if (timeLeft <= 0) {
        this.audio.playGameOver();
        this.orbitals.resetLevel();
        this.spawnElectrons();
      }
    });

    // Keyboard handler for closing tips with Escape
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (this.orbitals.showingTip) {
          this.orbitals.closeTip();
        } else {
          // Show tutorial when Escape is pressed and no tip is showing
          this.tutorial.show();
        }
      } else if (e.key === "m" || e.key === "M") {
        // Toggle mute with 'M' key
        const isMuted = this.audio.toggleMute();
        console.log(isMuted ? "Audio muted" : "Audio unmuted");
      } else if (e.key === "r" || e.key === "R") {
        // Restart from level 1 with 'R' key
        this.orbitals.currentLevel = 0;
        this.orbitals.score = 0;
        this.orbitals.resetLevel();
        this.spawnElectrons();
        this.audio.playUIHover();
        console.log("Restarted from level 1");
      }
    });

    this.gameLoop();

    // Show tutorial on first visit
    setTimeout(() => {
      if (this.tutorial.shouldShow()) {
        this.tutorial.show();
      }
    }, 1000); // Small delay to let the game load
  }

  spawnElectrons() {
    this.electrons = [];

    // Count and spawn electrons for each type
    ["blue", "orange"].forEach((type) => {
      let count = this.orbitals.orbitals.filter((o) => o.type === type).length;
      for (let i = 0; i < count; i++) {
        this.electrons.push(
          new Electron(
            Math.random() * (this.canvas.width - 100) + 50,
            Math.random() * (this.canvas.height - 100) + 50,
            type,
            this.audio
          )
        );
      }
    });
  }

  spawnParticles() {
    this.particles = [];
    // Create subtle background particles
    for (let i = 0; i < 30; i++) {
      this.particles.push({
        x: Math.random() * this.canvas.width,
        y: Math.random() * this.canvas.height,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        alpha: Math.random() * 0.4 + 0.1,
        phase: Math.random() * Math.PI * 2,
        size: Math.random() * 1.5 + 0.5,
      });
    }
  }

  update() {
    this.orbitals.update();

    // Update particles with subtle drift and twinkling
    for (let p of this.particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.phase += 0.02;

      // Wrap around edges
      if (p.x < 0) p.x = this.canvas.width;
      if (p.x > this.canvas.width) p.x = 0;
      if (p.y < 0) p.y = this.canvas.height;
      if (p.y > this.canvas.height) p.y = 0;
    }

    for (let electron of this.electrons) {
      electron.update(
        this.input.mouse.x,
        this.input.mouse.y,
        this.orbitals.orbitals,
        this.orbitals
      );
    }
  }

  draw() {
    this.ctx.fillStyle = "rgb(10,10,20)";
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    // Draw background particles
    this.ctx.save();
    for (let p of this.particles) {
      let twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(p.phase));
      this.ctx.fillStyle = `rgba(200,220,255,${p.alpha * twinkle})`;
      this.ctx.beginPath();
      this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      this.ctx.fill();
    }
    this.ctx.restore();

    // Draw cursor glow (only when tip is not showing)
    if (!this.orbitals.showingTip) {
      this.ctx.save();
      this.ctx.shadowColor = "rgba(100,150,255,0.6)";
      this.ctx.shadowBlur = 20;
      this.ctx.fillStyle = "rgba(100,150,255,0.2)";
      this.ctx.beginPath();
      this.ctx.arc(this.input.mouse.x, this.input.mouse.y, 15, 0, Math.PI * 2);
      this.ctx.fill();
      this.ctx.restore();
    }

    this.orbitals.draw(this.ctx);

    // Draw electrons (only when tip is not showing)
    if (!this.orbitals.showingTip) {
      for (let electron of this.electrons) {
        electron.draw(this.ctx);
      }
    }

    this.ctx.fillStyle = "rgba(255,255,255,0.7)";
    this.ctx.font = "12px Arial";
    this.ctx.fillText(
      "Spin-up (↑) repel, spin-down (↓) attract | M: Mute | R: Restart | Esc: Help",
      20,
      this.canvas.height - 20
    );
  }

  gameLoop() {
    this.update();
    this.draw();
    requestAnimationFrame(() => this.gameLoop());
  }

  // Method called by tutorial when ready to start
  start() {
    // Game is already running, this is just for tutorial integration
    console.log("Game started from tutorial");
  }
}


// Start the game
const game = new Game();
</script>
  </body>
</html>
