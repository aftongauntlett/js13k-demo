<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quantum Chaos - js13k Game</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #020408; /* Very dark laboratory background */
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: "Courier New", monospace; /* Scientific/technical font */
      }

      canvas {
        border: 1px solid rgba(100, 150, 255, 0.2); /* Subtle blue glow */
        cursor: crosshair;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #96c8ff; /* Scientific blue */
        font-size: 12px;
        opacity: 0.8;
        font-family: "Courier New", monospace;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">
      Quantum Chaos - Guide electrons to stable orbital configurations
    </div>

    <script>
      // Simple electron with polarity-based physics
      class Electron {
        constructor(x, y, type) {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 2;
          this.vy = (Math.random() - 0.5) * 2;
          this.type = type; // 'blue' or 'orange'
          this.radius = 8;
          this.captured = false;
        }

        update(mouseX, mouseY, orbitals) {
          if (this.captured) return;

          // Apply polarity-based force from mouse
          const dx = this.x - mouseX;
          const dy = this.y - mouseY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > 0) {
            const force = this.type === "blue" ? -0.15 : 0.15; // Blue repels, orange attracts
            const forceX = (dx / distance) * force;
            const forceY = (dy / distance) * force;

            this.vx += forceX;
            this.vy += forceY;
          }

          // Apply friction
          this.vx *= 0.98;
          this.vy *= 0.98;

          // Update position
          this.x += this.vx;
          this.y += this.vy;

          // Simple boundary constraints
          if (this.x < this.radius) {
            this.x = this.radius;
            this.vx = Math.abs(this.vx);
          }
          if (this.x > 800 - this.radius) {
            this.x = 800 - this.radius;
            this.vx = -Math.abs(this.vx);
          }
          if (this.y < this.radius) {
            this.y = this.radius;
            this.vy = Math.abs(this.vy);
          }
          if (this.y > 600 - this.radius) {
            this.y = 600 - this.radius;
            this.vy = -Math.abs(this.vy);
          }

          // Check orbital capture
          for (let orbital of orbitals) {
            if (!orbital.occupied && orbital.type === this.type) {
              const orbitalDx = this.x - orbital.x;
              const orbitalDy = this.y - orbital.y;
              const orbitalDistance = Math.sqrt(
                orbitalDx * orbitalDx + orbitalDy * orbitalDy
              );

              if (orbitalDistance < orbital.radius) {
                orbital.occupied = true;
                this.captured = true;
                this.x = orbital.x;
                this.y = orbital.y;
                break;
              }
            }
          }
        }

        draw(ctx) {
          if (this.captured) return;

          ctx.save();

          // Electron glow
          const gradient = ctx.createRadialGradient(
            this.x,
            this.y,
            0,
            this.x,
            this.y,
            this.radius
          );

          if (this.type === "blue") {
            gradient.addColorStop(0, "rgb(150, 200, 255)");
            gradient.addColorStop(1, "rgb(100, 150, 255)");
          } else {
            gradient.addColorStop(0, "rgb(255, 200, 150)");
            gradient.addColorStop(1, "rgb(255, 150, 100)");
          }

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }

      // Input handling system
      class InputSystem {
        constructor(canvas) {
          this.canvas = canvas;
          this.mouse = { x: canvas.width / 2, y: canvas.height / 2 };

          this.setupEventListeners();
        }

        setupEventListeners() {
          this.canvas.addEventListener("mousemove", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            this.mouse.x = e.clientX - rect.left;
            this.mouse.y = e.clientY - rect.top;
          });
        }
      }

      // Simple atomic orbital system with progressive levels
      class OrbitalSystem {
        constructor(canvas) {
          this.canvas = canvas;
          this.currentLevel = 0;
          this.score = 0;

          // Define simple atomic configurations with colored orbitals - reduced to 3 levels
          this.levels = [
            // Start with 2 targets
            {
              name: "Dipole",
              orbitals: [
                { x: 350, y: 300, radius: 25, type: "blue" },
                { x: 450, y: 300, radius: 25, type: "orange" },
              ],
            },
            // 3 targets
            {
              name: "Triangle",
              orbitals: [
                { x: 400, y: 250, radius: 25, type: "blue" },
                { x: 350, y: 350, radius: 25, type: "orange" },
                { x: 450, y: 350, radius: 25, type: "blue" },
              ],
            },
            // 4 targets
            {
              name: "Square",
              orbitals: [
                { x: 350, y: 250, radius: 25, type: "blue" },
                { x: 450, y: 250, radius: 25, type: "orange" },
                { x: 350, y: 350, radius: 25, type: "orange" },
                { x: 450, y: 350, radius: 25, type: "blue" },
              ],
            },
          ];

          this.resetLevel();
        }

        resetLevel() {
          this.orbitals = this.levels[this.currentLevel].orbitals.map((o) => ({
            x: o.x,
            y: o.y,
            radius: o.radius,
            type: o.type,
            occupied: false,
          }));
        }

        checkCompletion() {
          return this.orbitals.every((o) => o.occupied);
        }

        nextLevel() {
          if (this.checkCompletion()) {
            this.score += (this.currentLevel + 1) * 100;
            this.currentLevel++;
            if (this.currentLevel >= this.levels.length) {
              this.currentLevel = 0; // Loop back
            }
            this.resetLevel();
            return true;
          }
          return false;
        }

        draw(ctx) {
          // Draw orbitals
          for (let orbital of this.orbitals) {
            ctx.save();

            // Orbital glow
            const gradient = ctx.createRadialGradient(
              orbital.x,
              orbital.y,
              0,
              orbital.x,
              orbital.y,
              orbital.radius
            );

            if (orbital.occupied) {
              if (orbital.type === "blue") {
                gradient.addColorStop(0, "rgba(100, 150, 255, 0.6)");
                gradient.addColorStop(1, "rgba(100, 150, 255, 0)");
              } else {
                gradient.addColorStop(0, "rgba(255, 150, 100, 0.6)");
                gradient.addColorStop(1, "rgba(255, 150, 100, 0)");
              }
            } else {
              if (orbital.type === "blue") {
                gradient.addColorStop(0, "rgba(100, 150, 255, 0.3)");
                gradient.addColorStop(1, "rgba(100, 150, 255, 0)");
              } else {
                gradient.addColorStop(0, "rgba(255, 150, 100, 0.3)");
                gradient.addColorStop(1, "rgba(255, 150, 100, 0)");
              }
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(
              orbital.x - orbital.radius,
              orbital.y - orbital.radius,
              orbital.radius * 2,
              orbital.radius * 2
            );

            // Orbital ring
            if (orbital.type === "blue") {
              ctx.strokeStyle = orbital.occupied
                ? "rgb(100, 150, 255)"
                : "rgb(80, 120, 200)";
            } else {
              ctx.strokeStyle = orbital.occupied
                ? "rgb(255, 150, 100)"
                : "rgb(200, 120, 80)";
            }
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(orbital.x, orbital.y, orbital.radius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
          }

          // Simple UI
          ctx.fillStyle = "white";
          ctx.font = "16px Arial";
          ctx.fillText(`${this.levels[this.currentLevel].name}`, 20, 30);
          ctx.fillText(`Score: ${this.score}`, 20, 50);
          ctx.fillText(
            `Electrons: ${this.orbitals.filter((o) => o.occupied).length}/${
              this.orbitals.length
            }`,
            20,
            70
          );

          if (this.checkCompletion()) {
            ctx.fillStyle = "yellow";
            ctx.font = "24px Arial";
            ctx.fillText("Complete! Click for next level", 200, 100);
          }
        }
      }

      // Simple atomic physics game
      class Game {
        constructor() {
          this.canvas = document.getElementById("gameCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.canvas.width = 800;
          this.canvas.height = 600;

          // Systems
          this.input = new InputSystem(this.canvas);
          this.orbitals = new OrbitalSystem(this.canvas);

          // Electrons
          this.electrons = [];
          this.spawnElectrons();

          // Mouse click to advance levels
          this.canvas.addEventListener("click", () => {
            if (this.orbitals.checkCompletion()) {
              this.orbitals.nextLevel();
              this.spawnElectrons();
            }
          });

          this.gameLoop();
        }

        spawnElectrons() {
          this.electrons = [];

          // Count how many of each type we need
          const blueCount = this.orbitals.orbitals.filter(
            (o) => o.type === "blue"
          ).length;
          const orangeCount = this.orbitals.orbitals.filter(
            (o) => o.type === "orange"
          ).length;

          // Spawn blue electrons
          for (let i = 0; i < blueCount; i++) {
            this.electrons.push(
              new Electron(
                Math.random() * 700 + 50,
                Math.random() * 500 + 50,
                "blue"
              )
            );
          }

          // Spawn orange electrons
          for (let i = 0; i < orangeCount; i++) {
            this.electrons.push(
              new Electron(
                Math.random() * 700 + 50,
                Math.random() * 500 + 50,
                "orange"
              )
            );
          }
        }

        update() {
          for (let electron of this.electrons) {
            electron.update(
              this.input.mouse.x,
              this.input.mouse.y,
              this.orbitals.orbitals
            );
          }
        }
        draw() {
          // Clear canvas
          this.ctx.fillStyle = "rgb(10, 10, 20)";
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw systems
          this.orbitals.draw(this.ctx);

          for (let electron of this.electrons) {
            electron.draw(this.ctx);
          }

          // Instructions
          this.ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
          this.ctx.font = "12px Arial";
          this.ctx.fillText(
            "Orange electrons repel from mouse, blue attract | Match colors to orbitals",
            20,
            this.canvas.height - 20
          );
        }

        gameLoop() {
          this.update();
          this.draw();
          requestAnimationFrame(() => this.gameLoop());
        }
      }

      // Start the game
      const game = new Game();
    </script>
  </body>
</html>
